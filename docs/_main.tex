%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OXFORD THESIS TEMPLATE

% Use this template to produce a standard thesis that meets the Oxford University requirements for DPhil submission
%
% Originally by Keith A. Gillow (gillow@maths.ox.ac.uk), 1997
% Modified by Sam Evans (sam@samuelevansresearch.org), 2007
% Modified by John McManigle (john@oxfordechoes.com), 2015
% Modified by Ulrik Lyngs (ulrik.lyngs@cs.ox.ac.uk), 2018-, for use with R Markdown
%
% Ulrik Lyngs, 25 Nov 2018: Following John McManigle, broad permissions are granted to use, modify, and distribute this software
% as specified in the MIT License included in this distribution's LICENSE file.
%
% John commented this file extensively, so read through to see how to use the various options.  Remember that in LaTeX,
% any line starting with a % is NOT executed.

%%%%% PAGE LAYOUT
% The most common choices should be below.  You can also do other things, like replace "a4paper" with "letterpaper", etc.

% 'twoside' formats for two-sided binding (ie left and right pages have mirror margins; blank pages inserted where needed):
%\documentclass[a4paper,twoside]{templates/ociamthesis}
% Specifying nothing formats for one-sided binding (ie left margin > right margin; no extra blank pages):
%\documentclass[a4paper]{ociamthesis}
% 'nobind' formats for PDF output (ie equal margins, no extra blank pages):
%\documentclass[a4paper,nobind]{templates/ociamthesis}

% As you can see from the line below, oxforddown uses the a4paper size, 
% and passes in the binding option from the YAML header in index.Rmd:
\documentclass[a4paper, nobind]{templates/ociamthesis}


%%%%% ADDING LATEX PACKAGES
% add hyperref package with options from YAML %
\usepackage[pdfpagelabels]{hyperref}
% handle long urls
\usepackage{xurl}
% change the default coloring of links to something sensible
\usepackage{xcolor}
% change the alignment, this one provides better alignment with hyphenation (breaks words)
\usepackage{ragged2e}

\definecolor{mylinkcolor}{RGB}{0,0,139}
\definecolor{myurlcolor}{RGB}{0,0,139}
\definecolor{mycitecolor}{RGB}{0,33,71}

\hypersetup{
  hidelinks,
  colorlinks,
  linktocpage=true,
  linkcolor=mylinkcolor,
  urlcolor=myurlcolor,
  citecolor=mycitecolor
}


% add float package to allow manual control of figure positioning %
\usepackage{float}

% enable strikethrough
\usepackage[normalem]{ulem}

% use soul package for correction highlighting
\usepackage{color, soulutf8}
\definecolor{correctioncolor}{HTML}{CCCCFF}
\sethlcolor{correctioncolor}
\newcommand{\ctext}[3][RGB]{%
  \begingroup
  \definecolor{hlcolor}{#1}{#2}\sethlcolor{hlcolor}%
  \hl{#3}%
  \endgroup
}
% stop soul from freaking out when it sees citation commands
\soulregister\ref7
\soulregister\cite7
\soulregister\citet7
\soulregister\autocite7
\soulregister\textcite7
\soulregister\pageref7

%%%%% FIXING / ADDING THINGS THAT'S SPECIAL TO R MARKDOWN'S USE OF LATEX TEMPLATES
%pandoc unbounded added for pandoc 3.1.2+
\newcommand{\pandocbounded}[1]{#1}
% pandoc puts lists in 'tightlist' command when no space between bullet points in Rmd file,
% so we add this command to the template
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
 
% allow us to include code blocks in shaded environments
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}

% set white space before and after code blocks


\renewenvironment{Shaded}
{
  \vspace{10pt}%
  \begin{snugshade}%
}{%
  \end{snugshade}%
  \vspace{8pt}%
}

% User-included things with header_includes or in_header will appear here
% kableExtra packages will appear here if you use library(kableExtra)
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{xcolor}


%UL set section header spacing
\usepackage{titlesec}
% 
\titlespacing\subsubsection{0pt}{24pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}


%UL set whitespace around verbatim environments
\usepackage{etoolbox}
\makeatletter
\preto{\@verbatim}{\topsep=0pt \partopsep=0pt }
\makeatother


%%%%%%% PAGE HEADERS AND FOOTERS %%%%%%%%%
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\fancyhf{} % clear the header and footers
\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter. #1}{\thechapter. #1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection. #1}} 
\renewcommand{\headrulewidth}{0pt}

\fancyhead[LO]{\emph{\leftmark}} 
\fancyhead[RE]{\emph{\rightmark}} 




% UL page number position 
\fancyfoot[C]{\emph{\thepage}} %regular pages
\fancypagestyle{plain}{\fancyhf{}\fancyfoot[C]{\emph{\thepage}}} %chapter pages




%%%%% SELECT YOUR DRAFT OPTIONS
% This adds a "DRAFT" footer to every normal page.  (The first page of each chapter is not a "normal" page.)
\fancyfoot[C]{\emph{DRAFT on \today}}

% IP feb 2021: option to include line numbers in PDF

% for line wrapping in code blocks
\usepackage{fancyvrb}
\usepackage{fvextra}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines=true, breakanywhere=true, commandchars=\\\{\}}

% for quotations -- loaded here rather than in ociamthesis.cls, as it needs to
% be loaded after fvextra, otherwise we get a warning message
\usepackage{csquotes}

% This highlights (in blue) corrections marked with (for words) \mccorrect{blah} or (for whole
% paragraphs) \begin{mccorrection} . . . \end{mccorrection}.  This can be useful for sending a PDF of
% your corrected thesis to your examiners for review.  Turn it off, and the blue disappears.
\correctionstrue


%%%%% BIBLIOGRAPHY SETUP
% Note that your bibliography will require some tweaking depending on your department, preferred format, etc.
% If you've not used LaTeX before, I recommend just using pandoc for citations -- this is what's used unless you specific e.g. "citation_package: natbib" in index.Rmd
% If you're already a LaTeX pro and are used to natbib or something, modify as necessary.

% this allows the latex template to handle pandoc citations
% definitions for citeproc citations
\NewDocumentCommand\citeproctext{}{}
\NewDocumentCommand\citeproc{mm}{%
\begingroup\def\citeproctext{#2}\cite{#1}\endgroup}
\makeatletter
% allow citations to break across lines
\let\@cite@ofmt\@firstofone
% avoid brackets around text for \cite:
\def\@biblabel#1{}
\def\@cite#1#2{{#1\if@tempswa , #2\fi}}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newenvironment{CSLReferences}[2] % #1 hanging-indent, #2 entry-spacing
{\begin{list}{}{%
	\setlength{\itemindent}{0pt}
	\setlength{\leftmargin}{0pt}
	\setlength{\parsep}{0pt}
	% turn on hanging indent if param 1 is 1
	\ifodd #1
	\setlength{\leftmargin}{\cslhangindent}
	\setlength{\itemindent}{-1\cslhangindent}
	\fi
	% set entry spacing
	\setlength{\itemsep}{#2\baselineskip}}}
{\end{list}}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{\hfill\break\parbox[t]{\linewidth}{\strut\ignorespaces#1\strut}}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}




% Uncomment this if you want equation numbers per section (2.3.12), instead of per chapter (2.18):
%\numberwithin{equation}{subsection}


%%%%% THESIS / TITLE PAGE INFORMATION
% Everybody needs to complete the following:
\title{Extending Whole Program CFA for Integrity}
\author{Pratyush Choudhary}
\college{Indian Institute of Technology Gandhinagar}

% Master's candidates who require the alternate title page (with candidate number and word count)
% must also un-comment and complete the following three lines:

% Uncomment the following line if your degree also includes exams (eg most masters):
%\renewcommand{\submittedtext}{Submitted in partial completion of the}
% Your full degree name.  (But remember that DPhils aren't "in" anything.  They're just DPhils.)
\degree{Master of Technology}

% Term and year of submission, or date if your board requires (eg most masters)
\degreedate{May 2025}


%%%%% YOUR OWN PERSONAL MACROS
% This is a good place to dump your own LaTeX macros as they come up.

% To make text superscripts shortcuts
\renewcommand{\th}{\textsuperscript{th}} % ex: I won 4\th place
\newcommand{\nd}{\textsuperscript{nd}}
\renewcommand{\st}{\textsuperscript{st}}
\newcommand{\rd}{\textsuperscript{rd}}

%%%%% THE ACTUAL DOCUMENT STARTS HERE
\begin{document}

%%%%% CHANGE TO LEFT-ALIGNED
\RaggedRight

%%%%% CHOOSE YOUR LINE SPACING HERE
% This is the official option.  Use it for your submission copy and library copy:
\setlength{\textbaselineskip}{20pt plus2pt}
% This is closer spacing (about 1.5-spaced) that you might prefer for your personal copies:
%\setlength{\textbaselineskip}{18pt plus2pt minus1pt}

% You can set the spacing here for the roman-numbered pages (acknowledgements, table of contents, etc.)
\setlength{\frontmatterbaselineskip}{17pt plus1pt minus1pt}

% UL: You can set the line and paragraph spacing here for the separate abstract page to be handed in to Examination schools
\setlength{\abstractseparatelineskip}{13pt plus1pt minus1pt}
\setlength{\abstractseparateparskip}{0pt plus 1pt}

% UL: You can set the general paragraph spacing here - I've set it to 2pt (was 0) so
% it's less claustrophobic
\setlength{\parskip}{2pt plus 1pt}

%
% Customise title page
%
\def\crest{{\includegraphics[width=5cm]{templates/iitgnlogo.png}}}
\renewcommand{\university}{}
\renewcommand{\submittedtext}{A thesis submitted in partial fulfillment of the requirements for the degree of}
\renewcommand{\thesistitlesize}{\fontsize{22pt}{28pt}\selectfont}
\renewcommand{\gapbeforecrest}{25mm}
\renewcommand{\gapaftercrest}{25mm
}


% Leave this line alone; it gets things started for the real document.
\setlength{\baselineskip}{\textbaselineskip}


%%%%% CHOOSE YOUR SECTION NUMBERING DEPTH HERE
% You have two choices.  First, how far down are sections numbered?  (Below that, they're named but
% don't get numbers.)  Second, what level of section appears in the table of contents?  These don't have
% to match: you can have numbered sections that don't show up in the ToC, or unnumbered sections that
% do.  Throughout, 0 = chapter; 1 = section; 2 = subsection; 3 = subsubsection, 4 = paragraph...

% The level that gets a number:
\setcounter{secnumdepth}{2}
% The level that shows up in the ToC:
\setcounter{tocdepth}{1}


%%%%% ABSTRACT SEPARATE
% This is used to create the separate, one-page abstract that you are required to hand into the Exam
% Schools.  You can comment it out to generate a PDF for printing or whatnot.

% JEM: Pages are roman numbered from here, though page numbers are invisible until ToC.  This is in
% keeping with most typesetting conventions.
\begin{romanpages}

% Title page is created here
\maketitle

%%%%% DEDICATION

%%%%% ACKNOWLEDGEMENTS


\begin{acknowledgements}
 	This is where you will normally thank your advisor, colleagues, family and friends, as well as funding and institutional support. In our case, we will give our praises to the people who developed the ideas and tools that allow us to push open science a little step forward by writing plain-text, transparent, and reproducible theses in R Markdown.

 We must be grateful to John Gruber for inventing the original version of Markdown, to John MacFarlane for creating Pandoc (\url{http://pandoc.org}) which converts Markdown to a large number of output formats, and to Yihui Xie for creating \texttt{knitr} which introduced R Markdown as a way of embedding code in Markdown documents, and \texttt{bookdown} which added tools for technical and longer-form writing.

 Special thanks to \href{http://chester.rbind.io}{Chester Ismay}, who created the \texttt{thesisdown} package that helped many a PhD student write their theses in R Markdown. And a very special thanks to John McManigle, whose adaption of Sam Evans' adaptation of Keith Gillow's original maths template for writing an Oxford University DPhil thesis in LaTeX provided the template that I in turn adapted for R Markdown.

 Finally, profuse thanks to JJ Allaire, the founder and CEO of \href{http://rstudio.com}{RStudio}, and Hadley Wickham, the mastermind of the tidyverse without whom we'd all just given up and done data science in Python instead. Thanks for making data science easier, more accessible, and more fun for us all.

 \begin{flushright}
 Ulrik Lyngs \\
 Linacre College, Oxford \\
 2 December 2018
 \end{flushright}
\end{acknowledgements}



%%%%% ABSTRACT


\renewcommand{\abstracttitle}{Abstract}
\begin{abstract}
	This \emph{R Markdown} template is for writing an Oxford University thesis. The template is built using Yihui Xie's \texttt{bookdown} package, with heavy inspiration from Chester Ismay's \texttt{thesisdown} and the \texttt{OxThesis} \LaTeX~template (most recently adapted by John McManigle).

This template's sample content include illustrations of how to write a thesis in R Markdown, and largely follows the structure from \href{https://ulyngs.github.io/rmarkdown-workshop-2019/}{this R Markdown workshop}.

Congratulations for taking a step further into the lands of open, reproducible science by writing your thesis using a tool that allows you to transparently include tables and dynamically generated plots directly from the underlying data. Hip hooray!
\end{abstract}



%%%%% MINI TABLES
% This lays the groundwork for per-chapter, mini tables of contents.  Comment the following line
% (and remove \minitoc from the chapter files) if you don't want this.  Un-comment either of the
% next two lines if you want a per-chapter list of figures or tables.
\dominitoc % include a mini table of contents

% This aligns the bottom of the text of each page.  It generally makes things look better.
\flushbottom

% This is where the whole-document ToC appears:
\tableofcontents

\listoffigures
	\mtcaddchapter
  	% \mtcaddchapter is needed when adding a non-chapter (but chapter-like) entity to avoid confusing minitoc

% Uncomment to generate a list of tables:
\listoftables
  \mtcaddchapter
%%%%% LIST OF ABBREVIATIONS
% This example includes a list of abbreviations.  Look at text/abbreviations.tex to see how that file is
% formatted.  The template can handle any kind of list though, so this might be a good place for a
% glossary, etc.
% First parameter can be changed eg to "Glossary" or something.
% Second parameter is the max length of bold terms.
\begin{mclistof}{List of Abbreviations}{3.2cm}

\item[1-D, 2-D]

One- or two-dimensional, referring \textbf{in this thesis} to spatial dimensions in an image.

\item[Otter]

One of the finest of water mammals.

\item[Hedgehog]

Quite a nice prickly friend.

\end{mclistof} 


% The Roman pages, like the Roman Empire, must come to its inevitable close.
\end{romanpages}

%%%%% CHAPTERS
% Add or remove any chapters you'd like here, by file name (excluding '.tex'):
\flushbottom

% all your chapters and appendices will appear here
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# this line ensures that tinytex doesn\textquotesingle{}t try to update LaTeX packages on every single knit}
\FunctionTok{options}\NormalTok{(}\AttributeTok{tinytex.tlmgr\_update =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\chapter*{Introduction}\label{introduction}
\addcontentsline{toc}{chapter}{Introduction}

\adjustmtc
\markboth{Introduction}{}

\chapter{Background}\label{background}

\minitoc 

There are digital devices all around us running code written by people. It can be
to handle a simple electric toothbrush's timer, or to move a robot arm for a surgery.
And, all programs are not created equal. Some are mission-critical pieces of code that
may require high levels of scrutiny at each step of creation, lest they fail and
result in disasters - financial or otherwise.

For such a program running on a device, we need to ensure that it ran correctly
(meaning - as intended by the logic of the code).
But just writing ``good'' code doesn't save it from other factors that are present while running it.
There are a few factors that may influence the program to not behave correctly:{[}?? CITEME{]}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A bug in the code that slipped past the review process.
\item
  There's a flaw in the device that the code is running on.
\item
  A malicious actor attacks the device/program to modify the execution.
\item
  The device's environment is adversarial. Eg. A nuclear plant's control panel.
\end{enumerate}

For factors 1-2, there are techniques like source code auditing, testing,
fuzzing, static and dynamic program analysis, and formal verification that try to minimize the software/hardware bugs.
{[}\citeproc{ref-godefroid2012sage}{13}, \citeproc{ref-kern1999formal}{16}, \citeproc{ref-luk2005dynamic}{19}--\citeproc{ref-quinlan2009source}{22}{]}

For factor 3, there are various types of results that are possible ranging from
Denial of Service to Information Leak.
Our focus is on preventing the control flow (the order of instructions that run for a given input)
of the program from changing, and for that, the techniques come under the term
Control Flow Integrity (CFI).{[}\citeproc{ref-sok}{2}{]}

But what if the adversary is the device's environment like factor 4?
Or what do we do about the fact that we still cannot guarantee that the program is secure?
As stated by Bruce Schneier: Security is a process, not a product.{[}\citeproc{ref-bruceessay}{23}{]}
No system is fully secure, and security flaws are inevitable.
We need to at-least be able to prove in some way that the program behaved as intended.

For simple programs that process an input to give a deterministic output like
counting prime numbers or calculators, it is easy to just verify the output.
But for non-deterministic or complex programs with side-effects (changes to the
system or device - like writing to a file, or moving a robot arm), verifying the
output is not feasible. One way is to instrument the system to check that the
control flow of the program is as expected, which in turn may indicate
that the program ran correctly.
And the set of techniques for this instrumentation is called Control Flow
Attestation (CFA).

\section{Control Flow Techniques}\label{control-flow-techniques}

Let us now look at both CFI and CFA techniques in detail to know their aims and the current
capabilities afforded to us by them.

\subsection{CFI}\label{cfi}

\subsubsection{What and why?}\label{what-and-why}

When the program executes, it goes through a sequence of instructions. The order
of these instructions is determined by various factors including the input, current state,
and some decisions like if-else statements. That order is called the control flow
of the program, literally how the control of the program flows through the instructions.
If attackers try to modify how the program behaves, and run instructions
of their choosing, they modify the control flow of the program. And this type of attack is
called control-flow hijacking attack.
The set of techniques to provide integrity against these attacks is CFI.

\subsubsection{History and Techniques used}\label{history-and-techniques-used}

There are 3 main types of attacks that can change the control flow of a program {[}\citeproc{ref-sok}{2}{]}:

\begin{itemize}
\tightlist
\item
  Code injection: Attacker puts their own arbitrary code into the memory of the program and runs it.
\item
  Code reuse: Attacker uses the instructions already present in the program to execute operations.
\item
  Data manipulation: Attacker changes the data used to take decisions for the control flow.
\end{itemize}

To mitigate against execution of attacker controlled code, the common practice is
to add Data Execution Prevention (DEP) mechanisms. All parts of program memory except
(read-only) code sections are marked as non executable, so any injected code would not be executable.

Code reuse attacks then try to bypass DEP by using the existing code in memory to
execute arbitrary operations. The way to do that would be by changing the control
flow in a way that jumps between chosen code snippets. These attacks are called
Return-oriented programming (ROP) and Jump-oriented programming (JOP).
Some of the mitigations are Address Space Layout Randomization (ASLR),
Shadow Stacks, Stack Canaries, Pointer Authentication, and Branch Target Identification.
We'll discuss ROP/JOP with Pointer Authentication and Branch Target
Identification as their ARM implementations later on in section \hyperref[arm-specifics]{1.2 - ARM Specifics}.

Data manipulation attacks focus on changing the values of variables to change the control flow.
They have their own set of techniques countering and detecting the attacks called
Data Flow Integrity (DFI) and Data Flow Attestation (DFA). But they are complementary
but out of scope for us right now. Our focus will be on Code reuse attacks instead.

CFI was originally proposed by Abadi et al.{[}?? CITEME abadi{]} as a policy-based mitigation
against control flow hijacking attacks by restricting the execution of a program
to a pre-computed Control Flow Graph (CFG) {[}\citeproc{ref-sok}{2}{]}. This CFG could be statically or
dynamically generated, and a close approximation of the CFG would make it harder
for an attacker to manipulate the control flow as they want.

\subsection{CFA}\label{cfa}

\subsubsection{Why?}\label{why}

As noted previously, analysis, testing and even adding CFI doesn't mean the program is secure.
Also, there are many use-cases where we need an unforgeable evidence of the control flow
of a given program. For example, in a syringe pump, where this evidence could be
needed by hospital and insurance that it indeed delivered the given dosage and correctly at that.
This can be achieved by path attestation, where the verifier gets a non-repudiable
proof of execution on prover for the given input.
Path attestation also acts as a lighter alternative to verifiable computation {[}?? CITEME{]}.

There are other integrity measurements too that can attest to various properties
of the system being tested.
Like, weather the system satisfies certain properties {[}?? CITEME{]}, it booted up
with particular software stack {[}?? CITEME{]}, or that it executed certain operations correctly {[}?? CITEME{]}.

The work done on CFA has been parallel to CFI, but with an aligned objective {[}\citeproc{ref-sok}{2}{]}.
We will focus on path attestation, and whole program path in particular.
The reason for that is explained later in CFA - Techniques subsection.

\subsubsection{General Overview of the process}\label{general-overview-of-the-process}

\begin{figure}[H]

{\centering \includegraphics[width=0.5\linewidth]{./imgs/placeholder-cfa-workflow} 

}

\caption{Typical CFA Interaction}\label{fig:cfa-workflow}
\end{figure}

For CFA, the general workflow has 2 separate agents, a prover (Prv) and a remote verifier (Vrf).
The Vrf sends a request to Prv with a cryptographic challenge (Eg. a \emph{nonce}).
As a response to the challenge, Prv executes the program with the given
input (either implicitly or explicitly given in the request).
It then generates a report of execution (CFreport), and sends it to Vrf.
This CFreport is signed using the challenge sent by Vrf, and contains the output of the program and an
authenticated log (CFlog) of the control flow taken by the program during execution.

\emph{But how would the Vrf know that Prv has not forged the report?}
This is where a Root of Trust (RoT) comes in.
A Root of Trust (RoT) is a part of the system that we essentially \emph{trust} to work
properly even in adversarial conditions. This trust in the mechanism is assumed and not derived.
It then serves as the foundation on which the rest of the security guarantees
of the system can be derived. Commonly, systems have Trusted Execution Environments
(TEE) like Intel SGX {[}?? CITEME{]} or ARM TrustZone {[}?? CITEME{]} that act as the RoT.

In our case, it's a piece of hardware on Prv that monitors the system, validates its state,
and generates the CFlog and CFreport that's sent to Vrf.

When Vrf recieves CFreport, it uses it to determine whether the program was executed as expected by Prv.
It does so by checking if CFlog contains a valid control flow of the program
for the input. If the path is invalid, Vrf can also analyze CFlog to detect
deviations and determine the cause.

\subsubsection{Techniques used}\label{cfatechniques}

Remote attestation to establish memory content integrity has been explored previously
in various domains\sethlcolor{pink}\hl{??Add citations}\sethlcolor{correctioncolor}.
As TEEs were generally historically unavailable on low-end embedded devices,
software based attestation techniques like SWATT {[}?? CITEME{]} and PIONEER {[}??CITEME{]} were proposed.
They implemented software based self-checksum functions as a means of attestation.
They relied on precise timing measurements, and were applicable only in settings where
comunnication delay between Vrf and Prv is deterministic.

Then there are Hybrid attestation techniques, that aim to minimize changes to
underlying hardware, while giving same guarantees as hardware-based techniques.
VRASED {[}?? CITEME{]} adds integrity checks in software, while using trusted hardware to control the checks.

But these techniques measure the state of Prv only when remote attestation is executed.
They are oblivious to program's state between two consecutive measurements, or
information of program before measurements. That means they suffer from
time-of-check to time-of-use (TOCTOU) attacks. There are proposed designes that avoid this limitation.{[}?? CITEME RATA{]}

Works in path attestation, where the control flow path of the program is recorded
for the proof, include CFLAT {[}?? CITEME CFLAT{]} and OAT {[}?? CITEME OAT{]}.
We will focus on these two, as they can represent the main approaches to path
attestation, and other works have essentially similar methods {[}?? CITEME{]}.

CFLAT computes the hash of basic blocks by adding instrumentation at their end,
and then accumulates their hash which represents the execution path of the program.
The Vrf then compares it with historically collected expected hashes for known
execution paths.
OAT on the other hand, adds instrumentation after conditionals, which signifies
the direction the branches took. This, leads to less instrumentation compared to
CFLAT where every edge of the CFG is instrumented.
This information is saved in the TEE in the form of a bit-trace, along with
jump, call, and return addresses.
The Vrf then uses the bit trace and other values to perform a symbolic execution
of the program for verification.
Their instrumentation approaches for the CFG of a program
are shown in figure \ref{fig:cflat-oat-instruments}.
\sethlcolor{pink}\hl{Add cflat-oat-instruments.png}\sethlcolor{correctioncolor}

CFLAT and OAT have logging events for each Conditional Branch, Indirect function call, and Function exit.
Additionally, CFLAT also have events for Unconditional Branches and Direct function calls.
All of these events has a domain transition to TEE for logging. Which, when large codebases
are taken in account, can become a performace bottleneck due to the sheer number of them {[}\citeproc{ref-blast}{26}{]}.

\sethlcolor{pink}\hl{?? TABLE}\sethlcolor{correctioncolor} describes the number of TEE domain switches at runtime,
as seen for CFLAT and OAT for Embench-IOT benchmarks, when applied to whole programs.
It also shows the amount of extensive instrumentation that is needed for path attestation.
Despite such intrusive amount of instrumentation, which also translates into
a proportional number of domain switches, CFLAT and OAT report fairly low runtime overheads.
CFLAT reports runtime overhead in seconds when evaluated on a syringe pump application.
OAT reports an average runtime overhead of 2.7\% on 5 embedded applications.

This low overhead for both can be explained by the fact that their application
has been to small programs or ``operations'' that span a few thousand control-flow events.
When applied to whole programs, the overhead turns out to be more than 1000x.{[}\citeproc{ref-blast}{26}{]}
This means, a program that takes a few seconds would take hours to complete.
Other previous works, like CFLAT and OAT, have mostly been applied to small
programs or to programs that work in specialized environments {[}?? CITEME{]}{[}\citeproc{ref-blast}{26}{]}.
Prior work has also shown that a Vrf can miss attacks that are directed against
a program when paths in only some parts of it are attested {[}?? CITEME{]}.
Therefore, it's better for Vrf to be able to attest the entire execution of a program.

BLAST {[}\citeproc{ref-blast}{26}{]} was then proposed, which overcame the limitations of CFLAT and OAT while
also adding whole program control flow attestation capabilities. It's discussed
in detail later on in Primary Works - \hyperref[blast]{1.3.1 BLAST} subsection.

Also, most CFA techniques do not guarantee that the report will be recieved by Vrf.
The Vrf may not trust the output recieved by it unless CFlog is attached to it,
runtime auditing {[}?? CITEME, Sok 41,42{]} aims to bridge that gap and reliably deliver
CFlog even when Prv turns malicious and tries to not follow the protocol.

\section{ARM Specifics}\label{arm-specifics}

Now that we know \sethlcolor{pink}\hl{what CFI and CFA are}\sethlcolor{correctioncolor}, we can take a look at platform specific solutions.
For this work, we choose ARM as it's common in embedded applications{[}?? CITEME{]},
\sethlcolor{pink}\hl{which is a popular use-case where CFI and CFA techniques are often applied}\sethlcolor{correctioncolor}.\href{}{?? CITEME}

Before diving into the implementation details, we'll first discuss the ARM Architecture
(ARMv8-A specifically) and its calling conventions to brush up the required background knowledge.
We'll also discuss some architecture level features that can be used for CFI and CFA.

\subsection{ARM Assembly Basics}\label{arm-assembly-basics}

We will only focus on AArch64, the 64-bit instruction set, and on the ARMv8-A and later profiles{[}\citeproc{ref-arm-arch-manual}{7}{]}.

\subsubsection{Registers}\label{registers}

Let us first talk about Registers.
SIMD, floating point and vector registers will be excluded in this section for brevity.

In AArch64, the available registers are:{[}\citeproc{ref-armasm-user-guide}{4}, \citeproc{ref-arm-isa}{6}{]}

\begin{itemize}
\tightlist
\item
  31 64-bit general-purpose registers \texttt{x0\ -\ x30} which can hold any type of data.
  They usually hold integers and addresses, but anything with length of 64-bits
  can be stored in them. Their lower 32-bits can also be accessed and used as
  32-bit registers by using \texttt{wN} instead of \texttt{xN}, where \texttt{N} is the register number.
\item
  1 Program Counter \texttt{PC}.
\item
  1 Process State \texttt{PSTATE}.
\item
  \texttt{wzr/xzr} called zero register,
  which reads \texttt{0} and ignores the writes. Therefore it's only useful as a source.
  It doesn't represent a real register on chip,
  but it's just a symbol for ``assume value of operand to be zero''.
\item
  4 stack pointer registers \texttt{SP\_EL0\ -\ SP\_EL3}.
\item
  3 exception link registers \texttt{ELR\_EL1\ -\ ELR\_EL3}.
\item
  3 saved program status registers \texttt{SPSR\_EL1\ -\ SPSR\_EL3}. They are 32-bit wide only,
  unlike other registers.
\end{itemize}

There is no register \texttt{w31/x31}. Depending on instructions, the register number \texttt{31}
either represents the zero register or the stack pointer.

Depending on the Exception Level or privileged execution mode,
the Stack Pointer \texttt{SP} is represented by the corresponding \texttt{SP\_EL} register.

As we are talking about user level code (\texttt{EL0}) only, we will ignore the \texttt{ELR} and \texttt{SPSR}
registers, and consider \texttt{SP\_EL} registers to just be \texttt{SP}.

The registers and their usage are as follows:{[}\citeproc{ref-armasm-user-guide}{4}, \citeproc{ref-arm-isa}{6}, \citeproc{ref-arm-pcs}{8}{]}

\begin{itemize}
\tightlist
\item
  \texttt{x0} to \texttt{x7}:\\
  (Volatile) For passing arguments and return values for system and function calls.
  Additional arguments are stored on the stack.
  The return value is typically stored in \texttt{x0}. Caller assumes they will be modified.
\item
  \texttt{x8}:\\
  (Volatile) Indirect result location register. It is also typically used for holding
  syscall number.
\item
  \texttt{x9} to \texttt{x15}:\\
  (Volatile) General purpose, for storing temporary data. Caller saved.
\item
  \texttt{x16} and \texttt{x17}:\\
  (Volatile) Intra-procedure-call registers. Used as scratch
  registers by system linker during calls.
\item
  \texttt{x18}:\\
  Reserved for platform specific use. Usage is avoided for portability.
\item
  \texttt{x19} to \texttt{x28}:\\
  (Non-volatile) Callee-saved registers. They must be preserved across calls.
  If used, the callee must push the values to the stack at the beginning of function,
  and restore them before returning.
\item
  \texttt{x29} (Frame Pointer \texttt{FP}):\\
  (Non-volatile) Points to the start of the stack frame of a function.
\item
  \texttt{x30} (Link Register \texttt{LR}):\\
  (Non-volatile) Holds the return address of a function call.
  Can be used, but value must be restored before returning.
\item
  \texttt{SP} (Stack Pointer):\\
  Special Register. Points to the top of the stack.
  Can be used as base address register for loads and stores.
\item
  \texttt{PC} (Program Counter):\\
  Special Register. Cannot be accessed explicitly.
  Holds the address of the next instruction to be executed.
\item
  \texttt{PSTATE}:\\
  Holds the various status and control flags for the processor.
  They include Execution State, Interrupt Mask Bits, Processor Mode, Condition Flags,
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\emph{Sidenote:} XNU (Apple iOS and MacOS) ABI's conventions differ from the aforementioned one.
Although private and undocumented, it can be seen from the source {[}\citeproc{ref-apple-oss}{14}{]} that
the main differences (as of 02 May 2025) are:{[}\citeproc{ref-so-xnu-abi}{24}{]}

\begin{itemize}
\tightlist
\item
  The immidiate value passed to \texttt{svc} instruction is ignored. \texttt{svc\ 0x80} is used
  by the std library, which invokes a single handler.
\item
  The register used for syscalls is \texttt{x16} instead of \texttt{x8}.
\item
  The arguments are in \texttt{x0} through \texttt{x8} registers, supporting upto 9 arguments.
  This is only used if there's an indirect syscall i.e.~\texttt{x16\ =\ 0}.
\item
  Stack is not used for passing arguments.
\item
  \texttt{x0} and \texttt{x1} can hold 2 return values. For example in case of \texttt{fork}.
\item
  Error is reported using the carry bit, in which case \texttt{x0} would hold
  the error code.
\item
  Syscall numbers can be \emph{negative}.
  UNIX ones are non-negative as usual, ranging between \texttt{0} and \texttt{557}.
  Mach ones are negative with range between \texttt{-10} and \texttt{-100}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Calling (and Branching) Conventions}\label{calling-and-branching-conventions}

Now that we know the details about the registers, their usage and their volatility for a caller,
we can look at how functions are called in ARM architecture.

The main difference here from \texttt{x86-64} ISA is that we don't have a \texttt{call} instruction.
Instead branching instructions are used for conditionals, loops, and procedure calls.
We mainly have 5 types of Branching instructions:

\begin{itemize}
\tightlist
\item
  \texttt{B\ label} (Branch):\\
  Unconditional branch to a label within \texttt{PC} \(\pm\) \texttt{128MiB}.
  Not a subroutine call or return.
\item
  \texttt{B.cond\ label} (Branch Conditionally):\\
  Conditional branch to label within \texttt{PC} \(\pm\) \texttt{1MiB}.
  Not a subroutine call or return.
\item
  \texttt{BL\ label} (Branch with Link):\\
  Unconditional branch to label in range \(\pm\) \texttt{128MiB},
  and store the return address (\texttt{PC+4}) in \texttt{x30}.
  It is a subroutine call.
\item
  \texttt{BR\ xN}(Branch to Register):\\
  Unconditional branch to address in register \texttt{xN}.
  It is not a subroutine return.
\item
  \texttt{BLR\ xN} (Branch with Link to Register):\\
  Unconditional branch to address in register \texttt{xN},
  and store return address (\texttt{PC+4}) in \texttt{x30}.
  It is a subroutine call.
\end{itemize}

There are many other branching instructions too, like \texttt{CBZ}, \texttt{TBZ} etc.
but they are not relevant for us.

Now, we get 2 types of functions:

\begin{itemize}
\tightlist
\item
  \emph{Non-leaf} - Functions that call other functions.
\item
  \emph{Leaf} - Functions that don't have any function calls in their body, and simply return.
\end{itemize}

\emph{Why is it relevant?}
Because subroutine calls would use \texttt{BL}/\texttt{BLR} instructions,
and store the return address in \texttt{x30}.{[}\citeproc{ref-arm-arch-manual}{7}{]}
We don't need to worry about Leaf functions,
but what about nested Non-leaf function calls? \texttt{x30} would get overwritten.\\
To prevent that from happening, we make the distinction, and treat them differently.
For Non-leaf functions, we simply save the value in \texttt{x30} at the start of the function,
and restore it before return. It looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{foo:}
\NormalTok{  // save x30}
\NormalTok{  ...}
\NormalTok{  bl bar  }\OperatorTok{//}\NormalTok{ call bar}
\NormalTok{  ...}
\NormalTok{  // }\PreprocessorTok{restore}\NormalTok{ x30}
  \ControlFlowTok{ret}

\FunctionTok{bar:}
\NormalTok{  // save x30}
\NormalTok{  ...}
\NormalTok{  bl baz  }\OperatorTok{//}\NormalTok{ call baz}
\NormalTok{  ...}
\NormalTok{  // }\PreprocessorTok{restore}\NormalTok{ x30}
  \ControlFlowTok{ret}

\FunctionTok{baz:}
\NormalTok{  ...}
  \ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

\begin{quote}
\texttt{foo} and \texttt{bar} are non-leaf functions, whereas \texttt{baz} is a leaf function.
\end{quote}

\subsection{Pointer Authentication Code (PAC)}\label{pac-bg}

Pointer Authentication was added in ARMv8.3-A under the mandatory feature \texttt{FEAT\_PAuth}.{[}\citeproc{ref-arm-feat-names}{9}{]}
To understand PAC, we must first understand why and what does it aim to fix.

\subsubsection{Return Oriented Programming (ROP)}\label{return-oriented-programming-rop}

We have discussed how arbitrary code execution can be prevented.
This means that attackers can't inject and use arbitrary code, but what is stopping
them from using existing application code? Many applications are huge in size,
and that means there is a lot of code that has execute permissions already.
The attackers can analyze the application, and find out gadgets. Gadgets are executable
fragments of code, usually ending with a return. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\BuiltInTok{add}\NormalTok{ x0}\OperatorTok{,}\NormalTok{ x1}\OperatorTok{,}\NormalTok{ x2}
\ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

The attackers can then chain these gadgets together to form and execute their malicious code.
Any library that is in the address space of the process is a potential source of gadgets.
For example, GLIBC on ARM64, has almost 16,000 usable gadgets.{[}\citeproc{ref-riscyrop}{12}{]}
The ROP exploit process is described in figure \ref{fig:rop-diag}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-rop} 

}

\caption{Using ROP Gadgets}\label{fig:rop-diag}
\end{figure}

Although the process of finding and chaining the process is hard, it can be automated.
ASLR can make the process harder, but it is still possible to carry out ROP attacks using
Automated Exploit Generation (AEG) tools or information disclosure.{[}\citeproc{ref-aeg2014}{10}, \citeproc{ref-riscyrop}{12}{]}

\subsubsection{Solution?}\label{solution}

ROP exploits the fact that the return address is not checked, and can be used to
jump to next gadget instead. What if we check the return address for corruption
before using it? One way is using stack canaries, but even those can be bypassed
by memory disclosure vulnerabilities.

What if we sign the \texttt{LR}? The attacker would need a correctly signed address to replace it,
increasing the difficulty of exploit generation.
That's exactly what PAC does. Pointer Authentication
takes advantage of the fact that pointers are 64-bit long, but not all 64-bits
are needed to represent the virtual memory address.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-pac-bits} 

}

\caption{Pointer Layout on ARM64}\label{fig:pac-bits}
\end{figure}

PAC uses the top bits of the pointer to store a signature of the pointer
(as shown in fig \ref{fig:pac-bits}), and they aren't
used as a part of the address. At the start of the function, the \texttt{LR} is signed.
Then just before the return, the address is authenticated using PAC. If the check fails,
an exception is raised. Now, to perform a ROP attack, the attacker needs gadget addresses
(made harder with ASLR), and have properly signed pointers to those addresses.
To get a signed pointer, they would need to access a signing gadget.

After adding the PAC instructions, a function would look like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{foo:}
\NormalTok{  paciasp}
\NormalTok{  ...}
\NormalTok{  autiasp}
  \ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

\emph{Note:} If we don't need backwards compatibility, we can use \texttt{RETAA} which is equivalent to \texttt{AUTIASP\ +\ RET}.

\subsubsection{Using NOP space}\label{using-nop-space}

A subset of the PAC instructions are in the NOP-space. That means, if a
library or application uses the NOP-space instructions to add PAC support,
they can still run on old processors that do not support PAC features.
The instruction would just be treated as a \texttt{NOP}.
This is accomplished by encoding the instructions as ``hints'' to the processor.
These include: \texttt{AUTIx1716}, \texttt{AUTIxSP}, \texttt{AUTIxZ}, \texttt{PACIx1716}, \texttt{PACIxSP}, \texttt{PACIxZ} and \texttt{XPACLRI}.
Where (lower) \texttt{x} is either \texttt{A} or \texttt{B} depending on the key to be used.{[}\citeproc{ref-sipearl}{25}{]}
More in next section on keys. There are many more instructions,
but for now we'll just talk about these NOP-space ones.

\subsubsection{Forming a PAC}\label{forming-a-pac}

ARM provides 5 128-bit keys. Each of them is stored in a pair of 64-bit system registers:

\begin{itemize}
\tightlist
\item
  2 keys, A and B, for instruction pointers
\item
  2 keys, A and B, for data pointers
\item
  1 key for general use
\end{itemize}

And these registers are only accessible in EL1 and above (refer \ref{fig:armtz-arch}).
The signature is formed by using the key, address and a modifier as shown in figure \ref{fig:pac-diag}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-pac-diag} 

}

\caption{PAC formation}\label{fig:pac-diag}
\end{figure}

The strength of PAC depends on the size of the configured virtual address.
The keys have limited life spans, that is, each time the application is launched, the keys can be rotated.
And each application can have its own independent set of keys.
The modifier should be the same for sign-authenticate instruction pair on entry/exit.
So it specifies the context in which the pointer is valid in. For example,
using \texttt{SP} as the modifier would give us a PAC that's valid only for that call of the function,
as \texttt{SP} may be different on future calls.

The attacker would need to get every pointer correct in the chain, otherwise an
exception would be raised.

\sethlcolor{pink}\hl{Results discussed in chapter 3}\sethlcolor{correctioncolor}

\subsubsection{But what do these instructions mean?}\label{but-what-do-these-instructions-mean}

\begin{itemize}
\tightlist
\item
  \texttt{AUTI} prefix is an Authenticate instruction.
\item
  \texttt{PACI} prefix is a PAC computation instruction.
\item
  \texttt{A/B} after the prefix determines the key to be used.
\item
  \texttt{1716} suffix means address is in \texttt{x17}, modifier in \texttt{x16}.
\item
  \texttt{SP} suffix means address is in \texttt{x30}, modifier is \texttt{SP}.
\item
  \texttt{Z} suffix means address is in \texttt{x30}, modifier is \texttt{0}.
\item
  \texttt{XPACLRI} is used to strip PAC from address in \texttt{x30}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\emph{Sidenote:}
From ARMv9.4-A, under feature \texttt{FEAT\_PAuth\_LR}, \texttt{PACIxSPPC} and \texttt{AUTIxSPPC}
instructions were added to use \texttt{SP\ +\ PC} as the modifier to sign \texttt{LR}.
It gives better security by tying the caller and callee to the address,
and uniquely associating PAC with that particular instance of function usage.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

At the end, when enabled in the codebase, PAC looks like this:
\sethlcolor{pink}\hl{Add final example of PAC}\sethlcolor{correctioncolor}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{// source}
\NormalTok{// generated asm}
\end{Highlighting}
\end{Shaded}

\subsection{Branch Target Identification (BTI)}\label{bti-bg}

Branch Target Identification was added in ARMv8.5-A under the mandatory feature \texttt{FEAT\_BTI}.{[}\citeproc{ref-arm-feat-names}{9}{]}
Let us first understand where PAC was still inadequate, and what could be improved by using BTI.

\subsubsection{Jump Oriented Programming (JOP)}\label{jump-oriented-programming-jop}

PAC could add protection against ROP attacks by adding checks to ensure a
function returns to its true caller. That is protected the returning jump points.
But what about calling jump points like indirect branches, function pointers,
and case statements? JOP attacks use these points to pivot to next gadget in
sequence instead of \texttt{RET}. So JOP gadgets would end with \texttt{BR}, \texttt{BLR} or similar instructions instead.

\texttt{BR} and similar instructions use the register to determine the jump point, which
makes it hard to determine the target statically, or that the target would be valid.
This makes it easy for the attacker to use them to execute their JOP chain.

\sethlcolor{pink}\hl{fig: JOP.png}\sethlcolor{correctioncolor}

\subsubsection{Solution?}\label{solution-1}

If it is hard to statically secure the jump points, how about the landing points?
The hijacked jumps could target arbitrary locations to pivot to.
But valid code only jumps to particular locations. So, what if those locations
can be marked as landing points, and any jump that doesn't land on them becomes invalid?

This is the idea behind BTI. The branch targets are identified and marked with \texttt{BTI}
instructions that act as landing pads. Any jump that does not land on a \texttt{BTI} instruction
generates a Branch Target Exception.\footnote{\texttt{BRK,\ BTI,\ HLT,\ PACIASP} and \texttt{PACIBSP} are an exception to this.
  Refer instruction docs for details.{[}\citeproc{ref-armasm-user-guide}{4}{]}}
Function returns are also a type of indirect branch, but they aren't required
to target the landing pads. Also, for function entry,
pointer signing instructions \texttt{PACIxSP} and \texttt{PACIxZ} act like landing pads.

The \texttt{BTI} instruction has an argument that further specifies what types of indirect branch can it be targeted by:

\begin{itemize}
\tightlist
\item
  \texttt{BTI\ c}: Indirect function calls (\texttt{BLR})
\item
  \texttt{BTI\ j}: Indirect jumps (\texttt{BR}), e.g.~case-statements
\item
  \texttt{BTI\ jc}: Indirect function calls or jumps
\end{itemize}

There are some more rules to BTI like processor states for each target instruction type.
Please refer the Sipearl Whitepaper{[}\citeproc{ref-sipearl}{25}{]}, or Arm Documentation for PAC and BTI{[}\citeproc{ref-arm-pacbti}{5}{]} for more details.

\subsubsection{NOP-space}\label{nop-space}

Instructions added under BTI are also in NOP-space, so that all applications and
libraries that use it would be backwards compatible with old processors.

\sethlcolor{pink}\hl{Results discussed in chapter 3}\sethlcolor{correctioncolor}

\sethlcolor{pink}\hl{Add BTI example here}\sethlcolor{correctioncolor}

\subsection{ARM TrustZone}\label{arm-trustzone}

\begin{figure}[H]

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-armtz} 

}

\caption{ARM TrustZone Architecture}\label{fig:armtz-arch}
\end{figure}

ARM TrustZone{[}\citeproc{ref-armtz}{3}{]} is Arm's security architecture in ARM A-profile architecture.
It provides 2 execution environments with hardware enforced isolation between them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Normal World or Rich Execution Environment (REE) - It runs the regular software
  stack with a complex OS, hypervisor, etc. The attack surface is considered to be large,
  and the execution isn't trusted.
\item
  Trusted World/Execution Environment (TEE) - It runs a simple and small software
  stack which is assumed to be trusted. It has its own trusted services and OS.
  It also has a smaller attack surface due to its simplicity and size.
\end{enumerate}

There are 2 security states ARM architecture - Non-secure and Secure which map
to Rich and Trusted worlds respectively.
Exception levels are the levels of software execution privileges.
These mappings are specified in figure \ref{fig:armtz-arch}.
The states are often written with their exception levels like:

\begin{itemize}
\tightlist
\item
  \texttt{NS.EL2}: Non-secure state, Exception level 2
\item
  \texttt{S.EL2}: Secure state, Exception level 2
\end{itemize}

\emph{Note that EL3 is always in Secure State.}

\begin{figure}[H]

{\centering \includegraphics[width=0.75\linewidth]{./imgs/placeholder-smc-workflow} 

}

\caption{smc instruction call convention}\label{fig:smc-convention}
\end{figure}

This isolation is bridged by the usage of Secure Monitor Call (SMC) instruction.
The \texttt{smc} instruction not available in EL0 in either of the Security States.
The processes in Rich OS would call the user-space library (TEE Client),
which would in turn perform a low level call to the TrustZone driver in Rich OS.
The driver would then perform a \texttt{smc} call with arguments to the Secure Monitor.
The Secure Monitor determines the matching handler in TEE and dispatches it accordingly.
This process is shown in figure \ref{fig:smc-convention}.

\subsection{OP-TEE}\label{op-tee}

One example of a Trusted Kernel is OP-TEE. It was developed by ST-Ericsson,
and is now an open source project maintained by Linaro.{[}\citeproc{ref-optee}{18}{]}.
The rich applications call OP-TEE Driver through TEE Client API. The Driver
is then responsible for the communication with the OP-TEE kernel.

\begin{figure}[H]

{\centering \includegraphics[width=0.75\linewidth]{./imgs/placeholder-optee} 

}

\caption{OP-TEE Architecture}\label{fig:optee-arch}
\end{figure}

\section{Primary Works}\label{primary-works}

\subsection{BLAST}\label{blast}

As mentioned in \hyperref[cfatechniques]{1.1.2 CFA - Techniques}, attestation has rarely targeted whole programs.
And their approaches did not scale when applied to whole program paths, mainly
due to the sheer number of domain transitions between REE/TEE.{[}\citeproc{ref-blast}{26}{]}
BLAST{[}\citeproc{ref-blast}{26}{]} was developed in 2023 with whole program paths in mind.
They took inspiration from program profiling literature to decrease the said overheads.

\subsubsection{How it works}\label{how-it-works}

It is implemented as a LLVM pass that adds instrumentation to the binary for attestation.
BLAST reserves 2 registers called \texttt{BLReg} and \texttt{LogReg} for the required instrumentation.
We'll now discuss how it uses them and tries to optimise the attestation process.

\paragraph{Local Logging:}\label{local-logging}

If we need fine-grained logging, but cannot afford the domain switches, why not log inside the REE?
BLAST does this by pre-allocating a log inside the process's address space,
and adds SFI measures discussed in \hyperref[blastsfi]{SFI} to protect its integrity.
The log is shared between REE and TEE, and its permissions are managed by the TEE.
It is then divided in 2 halves, with each half ending with a write-protected page called \texttt{sentinel\ page}.
\texttt{LogReg} is a pointer to the head of the log, and BLAST simply adds the log entry
and increments its value.

\begin{figure}[H]

{\centering \includegraphics[width=0.6\linewidth]{./imgs/placeholder-blast-pages} 

}

\caption{Structure of the log in BLAST}\label{fig:blast-log-pages}
\end{figure}

When a half is filled, \texttt{LogReg} reaches a sentinel page and a hardware fault is generated on write.
The fault handler is then executed in the TEE, which:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Makes the \texttt{LogReg} point to the other half.
\item
  Adds write-protection to the filled half, to ensure it isn't overwritten.
\item
  Commits the log's state to the TEE.
\item
  After the log is committed, it makes the half writable again.
\end{enumerate}

\paragraph{Software Fault Isolation (SFI):}\label{blastsfi}

Sentinel pages are write-protected, but what about the regular log?
Although \texttt{LogReg} is reserved, and cannot be used by other parts of the code,
simple store instructions can still modify the log value. Only the instrumentation
instructions inserted as part of the BLAST pass should be allowed to append to the log.

To ensure this, BLAST adds instrumentation after each store instruction to:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Fetch the store address and the log's address.
\item
  Check that the store address doesn't lie inside the log.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{str}\NormalTok{ w8}\OperatorTok{,} \OperatorTok{[}\NormalTok{x29}\OperatorTok{,} \OperatorTok{\#}\DecValTok{4}\OperatorTok{]}                 \OperatorTok{//}\NormalTok{ perform the store}
\BuiltInTok{add}\NormalTok{ x9}\OperatorTok{,}\NormalTok{ x29}\OperatorTok{,} \OperatorTok{\#}\DecValTok{4}                   \OperatorTok{//}\NormalTok{ obtain the store address}
\BuiltInTok{and}\NormalTok{ x9}\OperatorTok{,}\NormalTok{ x9}\OperatorTok{,} \OperatorTok{\#}\BaseNTok{0x7ffffffffff00000}   \OperatorTok{//}\NormalTok{ mask the store address}
\NormalTok{ldr x10}\OperatorTok{,}\NormalTok{ log\_start\_addr           }\OperatorTok{//} \DecValTok{1}\ErrorTok{MB}\OperatorTok{{-}}\NormalTok{aligned log start}
\NormalTok{subs x9}\OperatorTok{,}\NormalTok{ x9}\OperatorTok{,}\NormalTok{ x10                  }\OperatorTok{//}\NormalTok{ if equal}\OperatorTok{,}\NormalTok{ then abort}\OperatorTok{.}
\NormalTok{b}\OperatorTok{.}\NormalTok{e \_abort}
\end{Highlighting}
\end{Shaded}

The log size is statically defined, and it is also aligned to that size.
i.e.~a 1MB log would be aligned to 1MB address. This makes the check equivalent
to a mask and subtract.

The reason for adding the check \emph{after} the store is to further ensure that a
CFI attack would not be able to bypass the check by jumping to the store.
The check would necessarily be run after the store, and therefore aborting the
execution if the log had been modified.

\paragraph{Optimizing log entries:}\label{optimizing-log-entries}

BLAST takes inspiration from profiling literature to place instrumentation in
an optimal fashion. It uses Ball-Larus algorithm {[}\citeproc{ref-balllarus}{11}{]} to selectively
add instrumentation to the edges of a CFG. The instrumentation manipulates the value of a counter,
which at the end of the CFG would be between \texttt{0} and \texttt{N-1}. Where \texttt{N} is the number
of acyclic paths in the CFG. This counter can be used to uniquely identify the
runtime path that was taken by the function.

This results in \texttt{2x} compact representation of paths compared to OAT's bit tracing,
and it places instrumentation at fewer locations.{[}\citeproc{ref-blast}{26}{]}

\paragraph{WPP:}\label{wpp}

BLAST then takes the large log, and compactly represents it using a context-free
grammar called Whole Program Path (WPP). It is an extension of Ball-Larus numbering, to build a single
control flow path through the complete program.{[}\citeproc{ref-laruswpp}{17}, \citeproc{ref-blast}{26}{]}
This takes the log, that can grow upto MBs or even GBs in size, and converts into
a WPP representation that's just a few hundred bytes big.

\subsubsection{Outcome}\label{outcome}

\sethlcolor{pink}\hl{Edit/Add to this part}\sethlcolor{correctioncolor}

\subsubsection{Limitations}\label{limitations}

The thread responsible of committing the log to TEE would have to run in parallel
to the program. Single core settings had an average runtime overhead of 175\%
as compared to 67\% of multi-core execution.{[}\citeproc{ref-blast}{26}{]}

Reserving 2 registers may cause compatibility issues, especially with programs
that rely on inline assembly. In which case, BLAST would not compile.

Also, the binary size overhead can be from 64\% upto 167\% with function inlining.
This would not be reasonable in certain applications or scenarios like lightweight embedded devices.

\subsection{CFA+}\label{cfa-1}

\subsubsection{How it works}\label{how-it-works-1}

\sethlcolor{pink}\hl{Edit/Add to this part}\sethlcolor{correctioncolor}

\begin{itemize}
\tightlist
\item
  Custom PAC
\item
  BTI
\item
  Logging?
\end{itemize}

\subsubsection{Outcome}\label{outcome-1}

\sethlcolor{pink}\hl{Edit/Add to this part}\sethlcolor{correctioncolor}

\subsubsection{Limitations}\label{limitations-1}

\sethlcolor{pink}\hl{One of the main limitations of CFA+ is that they do not mention what's their
(logging policy)?? for attestation. They do not elaborate on whether they have
fine-grained or course-grained CFA, or even what is their logging mechanism.
The benchmarks report performance that is too good for the number of domain
switches they'd need for committing the logs in TEE.}\sethlcolor{correctioncolor}
Also, the attestation architecture diagram given indicates that the attestation
agent is triggered on BTI violation, but the \sethlcolor{pink}\hl{text..where??}\sethlcolor{correctioncolor}
mentions logs to have a violation field. The field indicates weather an entry was due to violation.
This contradiction is not addressed in their paper.\sethlcolor{pink}\hl{verify this statement}\sethlcolor{correctioncolor}

\sethlcolor{pink}\hl{rolling their own CFI which has XOR loophole (verify!)}\sethlcolor{correctioncolor}

\chapter{Extending BLAST for CFI}\label{extending-blast-for-cfi}

\minitoc 

\emph{Armed} with the background information, we can now take a look at why and how we can improve
upon BLAST to give additional security guarantees, and maybe get a bit of a performance boost
while we are at it.

\section{Why?}\label{why-1}

CFA mechanisms rely on the fact that a malicious actor would not want their attack
to be detected. And for this there attack must not leave any trace in the log that
would be visible to the verifier. But what if the attacker does not care about if
their attack is visible or not, if the damage is done? Code reuse attacks become
very easy in this case, as most CFA techniques aim to detect them, but not prevent them.

Taking the example of the syringe pump, if an attacker has used ROP gadgets to
change the control flow of the pump to inject 10 ml instead of 1 ml, it doesn't
matter if we can detect if afterwards as the person's safety has already been compromised.

Our goal in this case is to prevent these kinds of scenarios.

People have been working on CFI and CFA parallelly as two solutions to similar
problems, but they have not thought about applying both of these together.{[}\citeproc{ref-cfaplus}{1}, \citeproc{ref-sok}{2}{]}
When applied together, these techniques sometimes complement each other and cover
each other's disadvantages. For example, adding integrity to some parts of the
code would remove the need for logging those parts, decreasing the runtime overhead
due to attestation, which is a common problem in the CFA literature.{[}\citeproc{ref-sok}{2}{]}

\sethlcolor{pink}\hl{CFA+ is there, but the limitations are listed, we need better solution.}\sethlcolor{correctioncolor}

\sethlcolor{pink}\hl{Also write about the constant monitor for input idea. BLAST is experiment in that direction}\sethlcolor{correctioncolor}

Before going forward, we should list out some of our assumptions:

\begin{itemize}
\tightlist
\item
  Write XOR Execute is enabled on pages. Code injection/modification in not possible.
\item
  Hardware is implicitly trusted.
\item
  Communication between Vrf and Prv is secure.
\item
  OS is not trusted if and only if page management and interrupt handling is mediated
  by the secure monitor.
\item
  Libraries are instrumented and statically linked to the binary.
\item
  \sethlcolor{pink}\hl{\ldots{}}\sethlcolor{correctioncolor}
\end{itemize}

\section{How to add Integrity guarantees?}\label{adding-integrity}

As discussed in \hyperref[cfi]{1.1.1 - CFI}, when talking about code reuse attacks, they can be further divided into
Control flow hijacking (control data) and Data only (non-control data) attacks.
We will talk about preventing control flow hijacking attacks first.
The two main categories of control flow hijacking attacks are: ROP and JOP.
We have talked about them in ARM Specifics \hyperref[pac-bg]{1.2.2 - PAC} and \hyperref[bti-bg]{1.2.3 - BTI} respectively.

Adding BTI to a binary would prevent JOP attacks disabling an attacker from changing
the control flow of the program and corrupting the forward edges of the CFG.
Use of \texttt{BR}, \texttt{BLR} and similar instructions to pivot to arbitrary code would generate hardware
level exceptions, which could then be logged and handled appropriately.

Similarly, adding PAC to a binary would prevent ROP attacks, disabling corruption
of backward egdes of the CFG.
Use of \texttt{RET} instructions to chain gadgets to run arbitrary code would become hard
as all returns would be preceded by an address check. Failing which would generate
a hardware level exception.

\sethlcolor{pink}\hl{cfa would detect \ldots{}\\
As for data only attacks, CFA part would handle it. how? repeat this ans in \#qual eval}\sethlcolor{correctioncolor}

We can also optionally enable Memory Tagging Extension (MTE), or memory coloring,
an Armv8.5-A extension {[}\citeproc{ref-arm-pacbti}{5}{]}. It enables detection of memory safety violations like use after free
and buffer overflows by assigning tags to memory regions. Any data access would
require a tag check in the address. Checking and Violations can be handled both
synchronously and asynchronously depending on performance needs.
As the tags, like PAC, use upper bits of the address, PAC would have fewer bits available.

But, MTE support for processors and Kernel is in early stage and is actively being worked upon.{[}\citeproc{ref-mte-kern-patch}{27}{]}
Therefore, we will skip this feature for now and it can be used in the future when platforms
have better support for it.

We have some more instructions provided by the PAC and BTI feature flags,
like \texttt{BLRAA} - Authenticate and branch, or \texttt{RETAA} - Authenticate and return.
But they are not in the NOP-space. So for the sake of backwards compatibility,
we choose to not use them for now.

\subsubsection{But, do PAC and BTI help in limiting the number of gadgets?}\label{but-do-pac-and-bti-help-in-limiting-the-number-of-gadgets}

According to ARM's testing, when these features were enabled for GLIBC, the number
of available gadgets was reduced by 97.65\%. This can be seen in figure \ref{fig:pac-bti-gadgets}.
Similar results were also seen for CFA+{[}\citeproc{ref-cfaplus}{1}{]}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-pac-bti-gadgets} 

}

\caption{ROP and JOP gadgets in GLIBC}\label{fig:pac-bti-gadgets}
\end{figure}

\subsubsection{What about the binary size overhead then?}\label{what-about-the-binary-size-overhead-then}

Binary size overhead for these, when checked for GLIBC by ARM, was 2.9\% for both
when considering backwards compatibility. If compiled for Armv8.3-A and later,
it drops to 1.61\% {[}\citeproc{ref-arm-pacbti}{5}{]}.
This overhead is less significant when compared to BLAST instrumentation, which
came to 64\% without inlining {[}\citeproc{ref-blast}{26}{]}.

\sethlcolor{pink}\hl{We will discuss this further in \#eval after we implement extended BLAST.}\sethlcolor{correctioncolor}

\subsubsection{What is our target compatibility?}\label{what-is-our-target-compatibility}

As mentioned previously, PAC and BTI can be backwards compatible with ARMv8-A processors
that do not support them, but will just be treated as \texttt{NOP} instructions.
The same binary would run on ARMv8.5-A processors with PAC + BTI guarantees, and
ARMv8.3-A with BTI turned off.
We also should keep in mind that PAC support is only enabled if the linked libraries
are also PAC enabled.
Compatibility is discussed in further detail in section \hyperref[compatibility]{3.2 Compatibility}.

\section{PAC + BTI gives us room to optimize BLAST}\label{optimizing-blast}

Now that we have checks on branches and calls, we do not need to log each loop's iteration.
Loop labels are protected by \texttt{BTI\ j} landing pads. They cannot be jumped to arbitrarily.
And as for the jumps: \texttt{B}, \texttt{B.cond}, \texttt{BL} have labels, and are direct branches protected
against code modification.
While \texttt{BR} and \texttt{BLR} use registers, and would not be used for loop control,
they still cannot jump arbitrarily as they would be preceded by pointer authentication.
Similarly, funtion returns aren't required to target landing pads, and may target loop labels,
but due to PAC, all returns would be authenticated first.

Due to this, we can skip logging each loop iteration which would result in less
log entries, and subsequently less number of domain switches. The amount of logging
decreased is equal to \sethlcolor{pink}\hl{TABLE's loop headers column. This comes out to be
equal to X\% of BLAST's entries. The performance benifits are discussed in \#eval.}\sethlcolor{correctioncolor}

\section{Log Levels for control over report granularity}\label{log-levels-for-control-over-report-granularity}

Now, what if we need fine-grained CFlog reports with each log iteration, etc?
Or what if we need more performance out of extended BLAST at the cost of CFlog granularity?

We can add log levels to BLAST then. These are:

\begin{itemize}
\tightlist
\item
  \emph{Violation}: Coarse-grained. Only PAC/BTI faults are logged and handled.
\item
  \emph{Inter-procedure}: Extended BLAST. Loop events aren't logged.
\item
  \emph{Intra-procedure}: Fine-grained. Original BLAST. Loop events are logged at cost of performance.
\end{itemize}

One thing to note here is that, BLAST instrumentation is added statically to the binary.
This means the log levels are set at compile time, and cannot be changed at runtime.

\chapter{Evaluation}\label{evaluation}

\minitoc 

\section{Qualitative Security Analysis}\label{qualitative-security-analysis}

For our case, an attacker either controls the Prv or is a malicious Prv that changes
the control flow of the program, while trying to keep the CFlog intact
or succeeds in completing malicious operations before Vrf gets the report.
A weaker set of these guarantees provided by BLAST, target an attacker that changes the control flow,
but cares about not being detected.
As described in sections \hyperref[adding-integrity]{2.2 - Adding Integrity} and
\hyperref[optimizing-blast]{2.3 - Optimizing Blast}, we add on top this weaker set of guarantees,
to provide the integrity guarantees.

Code corruption attacks that would replace the code can be prevented
as the function calls and returns would generate exceptions without properly signed
addresses. And even still, attacks would be detected as the call/return addresses and
the path numbers collected in the CFlog would not match. For code injection attacks,
we assume that Prv has data-execution prevention implemented in the REE.
For ensuring the integrity of the CFlog, all memory stores from code already inside the
program are followed by SFI instrumentation.

As for the possibility of code-reuse attacks, the target surface for any jumps is
decreased just to \texttt{bti} instructions, while the jumps (and returns) themselves are
protected by pointer authentication. The increase in binary sizes from enabling BTI is \textasciitilde2\% {[}\citeproc{ref-arm-pacbti}{5}{]},
that means the jump target surface for code-reuse attacks decreases to that amount.
Attacker would need to target those gadgets, while also considering
pointer authentication. Any successfull attacks bypassing these measures, would
be detected in the CFlog due to BLAST instrumentation. To prevent detection,
attacker would also need to find gadgets in the reduced subset to modify \texttt{BLReg} and \texttt{LogReg}.
BLAST already provides guarantees against bypassing detection {[}\citeproc{ref-blast}{26}{]}.

Attacks to program data to alter the control flow of a program is detected in the CFlog.
But, it would still be possible to alter the sensitive variables in a way that
does not affect the control flow. These attacks are not in our scope or the threat model.
However, this can be addressed by adding instrumentation that also logs the values
of sensitive variables alongside the CFlog {[}?? CITEME BLAST-47{]}.

Reliable, Continuous or On-demand delivery of CFreport is orthogonal to this work, but can
be added on top to provide additional guarantees. TA can be configured to send
continuous reports, so that Vrf can detect attacks early on and take action accordingly.
Also, the CFI exception handlers can be configured to report violations, and take
measures to abort execution or perform recovery. This is especially useful
in applications where active attacks are absent, but we need similar guarantees on
execution of the operations. For example, a rover, satellite or a robotic arm controller.

\section{Compatibility}\label{compatibility}

Although the measures described so far are ARM specific, the concepts themselves
are portable to other platforms and targets.
For example, if PAC is replaced with something else, which provides similar
guarantees, our techniques would still work. Case in point, Intel has Indirect
Branch Tracking (IBT) for x86-64 which gives instructions that act as branch targets {[}\citeproc{ref-intel-ibt}{15}{]}.

As for the compatibility of the prototype, if compiled with \texttt{-march=armv8a}, it
provides a binary that's backwards compatible with ARMv8-A processors,
but does not provide the integrity guarantees.
The integrity additions are only fully supported on ARMv8.5-A and later microarchitectures.
So, the prototype is fully compatible with those, while providing only attestation for
backwards compatible platforms.

This work, as with BLAST, can be applied to other CFA approaches to provide
integrity and/or performance. Similarly, Data Flow Integrity and Data Flow Attestation
techniques are complementary to this.

\section{Performance}\label{performance}

\chapter{Discussion}\label{discussion}

\minitoc 

\section{Limitations}\label{limitations-2}

\sethlcolor{pink}\hl{Edit/Add to this part}\sethlcolor{correctioncolor}

Although not a limitation in this work, our aim was to add checks in the TEE
that would monitor the program execution and if integrity has been violated,
abort the execution. We can pursue this further by modifying CFLAT/OAT monitor.

The benchmarks do not include whole program path generation part.

The logging on violation part, although mentioned has not been implemented yet
in the prototype. This can also be implementation dependent and users may choose
to abort execution instead of logging.

Some of the assumptions like write XOR execute are not foolproof and there are
proof of concepts exploiting them. We need to decrease the TCB and the
assumptions to increase the security guarantees given by this work.

Could not add other CFI measures than PAC and BTI.

PAC is only enabled if the whole dependency chain also has it enabled so we
cannot use PAC with pre-compiled binaries that do not have it enabled.

The benchmarking was done on a simulated Raspberry pi inside qemu instead of a
hardware board. Thus we have only taken the ratio of baseline code and the
instrumented code. The timings may differ a bit on a physical board.

\section{Why is it better than CFA+}\label{why-is-it-better-than-cfa}

\section{Future Research}\label{future-research}

\chapter*{Conclusion}\label{conclusion}
\addcontentsline{toc}{chapter}{Conclusion}

\startappendices

\chapter{The First Appendix}\label{the-first-appendix}

This first appendix includes an R chunk that was hidden in the document (using \texttt{echo\ =\ FALSE}) to help with readibility:

\textbf{In 02-rmd-basics-code.Rmd}

\textbf{And here's another one from the same chapter, i.e.~Chapter \ref{code}:}

\chapter{The Second Appendix, for Fun}\label{the-second-appendix-for-fun}

\chapter*{References}\label{references}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{}

\phantomsection\label{refs}
\begin{CSLReferences}{0}{0}
\bibitem[\citeproctext]{ref-cfaplus}
\CSLLeftMargin{{[}1{]} }%
\CSLRightInline{Mahmoud Ammar, Ahmed Abdelraoof, and Silviu Vlasceanu. 2024. On bridging the gap between control flow integrity and attestation schemes. In \emph{33rd USENIX security symposium (USENIX security 24)}, 2024. 6633--6650.}

\bibitem[\citeproctext]{ref-sok}
\CSLLeftMargin{{[}2{]} }%
\CSLRightInline{Mahmoud Ammar, Adam Caulfield, and Ivan De Oliveira Nunes. 2024. Sok: Integrity, attestation, and auditing of program execution. In \emph{2025 IEEE symposium on security and privacy (SP)}, 2024. IEEE Computer Society, 77--77.}

\bibitem[\citeproctext]{ref-armtz}
\CSLLeftMargin{{[}3{]} }%
\CSLRightInline{Arm. 2020. TrustZone for Armv8-a. Retrieved from \url{https://developer.arm.com/-/media/Arm\%20Developer\%20Community/PDF/Learn\%20the\%20Architecture/TrustZone\%20for\%20Armv8-A.pdf?revision=c3134c8e-f1d0-42ff-869e-0e6a6bab824f}}

\bibitem[\citeproctext]{ref-armasm-user-guide}
\CSLLeftMargin{{[}4{]} }%
\CSLRightInline{Arm. 2023. Arm compiler armasm user guide v6.6.5. Retrieved from \url{https://developer.arm.com/documentation/dui0801/l}}

\bibitem[\citeproctext]{ref-arm-pacbti}
\CSLLeftMargin{{[}5{]} }%
\CSLRightInline{Arm. 2023. Learn the architecture - providing protection for complex software v2.0. Retrieved from \url{https://developer.arm.com/documentation/102433/0200}}

\bibitem[\citeproctext]{ref-arm-isa}
\CSLLeftMargin{{[}6{]} }%
\CSLRightInline{Arm. 2024. Learn the architecture - A64 instruction set architecture guide v1.2. Retrieved from \url{https://developer.arm.com/documentation/102374/0102}}

\bibitem[\citeproctext]{ref-arm-arch-manual}
\CSLLeftMargin{{[}7{]} }%
\CSLRightInline{Arm. 2024. Arm architecture reference manual for a-profile architecture vL.a. Retrieved from \url{https://developer.arm.com/documentation/ddi0487/la/}}

\bibitem[\citeproctext]{ref-arm-pcs}
\CSLLeftMargin{{[}8{]} }%
\CSLRightInline{Arm. 2025. Procedure call standard for the arm 64-bit architecture. Retrieved from \url{https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst}}

\bibitem[\citeproctext]{ref-arm-feat-names}
\CSLLeftMargin{{[}9{]} }%
\CSLRightInline{Arm. 2025. Feature names in a-profile architecture v2025\_03. Retrieved from \url{https://developer.arm.com/documentation/109697/2025_03}}

\bibitem[\citeproctext]{ref-aeg2014}
\CSLLeftMargin{{[}10{]} }%
\CSLRightInline{Thanassis Avgerinos, Sang Kil Cha, Alexandre Rebert, Edward J Schwartz, Maverick Woo, and David Brumley. 2014. Automatic exploit generation. \emph{Communications of the ACM} 57, 2 (2014), 74--84.}

\bibitem[\citeproctext]{ref-balllarus}
\CSLLeftMargin{{[}11{]} }%
\CSLRightInline{Thomas Ball and James R Larus. 1996. Efficient path profiling. In \emph{Proceedings of the 29th annual IEEE/ACM international symposium on microarchitecture. MICRO 29}, 1996. IEEE, 46--57.}

\bibitem[\citeproctext]{ref-riscyrop}
\CSLLeftMargin{{[}12{]} }%
\CSLRightInline{Tobias Cloosters, David Paaen, Jianqiang Wang, Oussama Draissi, Patrick Jauernig, Emmanuel Stapf, Lucas Davi, and Ahmad-Reza Sadeghi. 2022. Riscyrop: Automated return-oriented programming attacks on risc-v and arm64. In \emph{Proceedings of the 25th international symposium on research in attacks, intrusions and defenses}, 2022. 30--42.}

\bibitem[\citeproctext]{ref-godefroid2012sage}
\CSLLeftMargin{{[}13{]} }%
\CSLRightInline{Patrice Godefroid, Michael Y Levin, and David Molnar. 2012. SAGE: Whitebox fuzzing for security testing. \emph{Communications of the ACM} 55, 3 (2012), 40--44.}

\bibitem[\citeproctext]{ref-apple-oss}
\CSLLeftMargin{{[}14{]} }%
\CSLRightInline{Apple Inc. 2025. XNU source - apple OSS distributions. Retrieved from \url{https://github.com/apple-oss-distributions/xnu}}

\bibitem[\citeproctext]{ref-intel-ibt}
\CSLLeftMargin{{[}15{]} }%
\CSLRightInline{Intel. 2023. 12th generation intel core processors datasheet. Retrieved from \url{https://edc.intel.com/content/www/us/en/design/ipla/software-development-platforms/client/platforms/alder-lake-desktop/12th-generation-intel-core-processors-datasheet-volume-1-of-2/010/indirect-branch-tracking/}}

\bibitem[\citeproctext]{ref-kern1999formal}
\CSLLeftMargin{{[}16{]} }%
\CSLRightInline{Christoph Kern and Mark R Greenstreet. 1999. Formal verification in hardware design: A survey. \emph{ACM Transactions on Design Automation of Electronic Systems (TODAES)} 4, 2 (1999), 123--193.}

\bibitem[\citeproctext]{ref-laruswpp}
\CSLLeftMargin{{[}17{]} }%
\CSLRightInline{James R Larus. 1999. Whole program paths. \emph{ACM SIGPLAN Notices} 34, 5 (1999), 259--269.}

\bibitem[\citeproctext]{ref-optee}
\CSLLeftMargin{{[}18{]} }%
\CSLRightInline{Linaro Limited. 2025. OPTEE - TrustedFirmware. Retrieved from \url{https://www.trustedfirmware.org/projects/op-tee/}}

\bibitem[\citeproctext]{ref-luk2005dynamic}
\CSLLeftMargin{{[}19{]} }%
\CSLRightInline{Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin: Building customized program analysis tools with dynamic instrumentation. \emph{Acm sigplan notices} 40, 6 (2005), 190--200.}

\bibitem[\citeproctext]{ref-millerfuzzing}
\CSLLeftMargin{{[}20{]} }%
\CSLRightInline{Barton P Miller, Lars Fredriksen, and Bryan So. 1990. An empirical study of the reliability of UNIX utilities. \emph{Communications of the ACM} 33, 12 (1990), 32--44.}

\bibitem[\citeproctext]{ref-artoftesting}
\CSLLeftMargin{{[}21{]} }%
\CSLRightInline{Glenford J Myers, Corey Sandler, and Tom Badgett. 2011. \emph{The art of software testing}. John Wiley \& Sons.}

\bibitem[\citeproctext]{ref-quinlan2009source}
\CSLLeftMargin{{[}22{]} }%
\CSLRightInline{Daniel Quinlan and Thomas Panas. 2009. Source code and binary analysis of software defects. In \emph{Proceedings of the 5th annual workshop on cyber security and information intelligence research: Cyber security and information intelligence challenges and strategies}, 2009. 1--4.}

\bibitem[\citeproctext]{ref-bruceessay}
\CSLLeftMargin{{[}23{]} }%
\CSLRightInline{Bruce Schneier. 2000. The process of security. Retrieved from \url{https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html}}

\bibitem[\citeproctext]{ref-so-xnu-abi}
\CSLLeftMargin{{[}24{]} }%
\CSLRightInline{Siguza. 2023. XNU systemcall ABI summary - StackOverflow. Retrieved from \url{https://stackoverflow.com/a/56993314}}

\bibitem[\citeproctext]{ref-sipearl}
\CSLLeftMargin{{[}25{]} }%
\CSLRightInline{Sipearl. 2023. Control flow integrity on Arm64 systems. Retrieved from \url{https://sipearl.com/sipearl-white-paper-anti-malware-active-protection-on-arm64-systems}}

\bibitem[\citeproctext]{ref-blast}
\CSLLeftMargin{{[}26{]} }%
\CSLRightInline{Nikita Yadav and Vinod Ganapathy. 2023. Whole-program control-flow path attestation. In \emph{Proceedings of the 2023 ACM SIGSAC conference on computer and communications security}, 2023. 2680--2694.}

\bibitem[\citeproctext]{ref-mte-kern-patch}
\CSLLeftMargin{{[}27{]} }%
\CSLRightInline{Yeoreum Yun. 2025. Kernel patch - support for FEAT\_MTE\_STORE\_ONLY feature. Retrieved from \url{https://lwn.net/ml/all/20250507154654.1937588-1-yeoreum.yun@arm.com/}}

\end{CSLReferences}

%%%%% REFERENCES


\end{document}
