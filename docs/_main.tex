%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% OXFORD THESIS TEMPLATE

% Use this template to produce a standard thesis that meets the Oxford University requirements for DPhil submission
%
% Originally by Keith A. Gillow (gillow@maths.ox.ac.uk), 1997
% Modified by Sam Evans (sam@samuelevansresearch.org), 2007
% Modified by John McManigle (john@oxfordechoes.com), 2015
% Modified by Ulrik Lyngs (ulrik.lyngs@cs.ox.ac.uk), 2018-, for use with R Markdown
%
% Ulrik Lyngs, 25 Nov 2018: Following John McManigle, broad permissions are granted to use, modify, and distribute this software
% as specified in the MIT License included in this distribution's LICENSE file.
%
% John commented this file extensively, so read through to see how to use the various options.  Remember that in LaTeX,
% any line starting with a % is NOT executed.

%%%%% PAGE LAYOUT
% The most common choices should be below.  You can also do other things, like replace "a4paper" with "letterpaper", etc.

% 'twoside' formats for two-sided binding (ie left and right pages have mirror margins; blank pages inserted where needed):
%\documentclass[a4paper,twoside]{templates/ociamthesis}
% Specifying nothing formats for one-sided binding (ie left margin > right margin; no extra blank pages):
%\documentclass[a4paper]{ociamthesis}
% 'nobind' formats for PDF output (ie equal margins, no extra blank pages):
%\documentclass[a4paper,nobind]{templates/ociamthesis}

% As you can see from the line below, oxforddown uses the a4paper size, 
% and passes in the binding option from the YAML header in index.Rmd:
\documentclass[a4paper, nobind]{templates/ociamthesis}


%%%%% ADDING LATEX PACKAGES
% add hyperref package with options from YAML %
\usepackage[pdfpagelabels]{hyperref}
% handle long urls
\usepackage{xurl}
% change the default coloring of links to something sensible
\usepackage{xcolor}
% change the alignment, this one provides better alignment with hyphenation (breaks words)
\usepackage{ragged2e}

\definecolor{mylinkcolor}{RGB}{0,0,139}
\definecolor{myurlcolor}{RGB}{0,0,139}
\definecolor{mycitecolor}{RGB}{0,33,71}

\hypersetup{
  hidelinks,
  colorlinks,
  linktocpage=true,
  linkcolor=mylinkcolor,
  urlcolor=myurlcolor,
  citecolor=mycitecolor
}


% add float package to allow manual control of figure positioning %
\usepackage{float}

% enable strikethrough
\usepackage[normalem]{ulem}

% use soul package for correction highlighting
\usepackage{color, soulutf8}
\definecolor{correctioncolor}{HTML}{CCCCFF}
\sethlcolor{correctioncolor}
\newcommand{\ctext}[3][RGB]{%
  \begingroup
  \definecolor{hlcolor}{#1}{#2}\sethlcolor{hlcolor}%
  \hl{#3}%
  \endgroup
}
% stop soul from freaking out when it sees citation commands
\soulregister\ref7
\soulregister\cite7
\soulregister\citet7
\soulregister\autocite7
\soulregister\textcite7
\soulregister\pageref7

%%%%% FIXING / ADDING THINGS THAT'S SPECIAL TO R MARKDOWN'S USE OF LATEX TEMPLATES
%pandoc unbounded added for pandoc 3.1.2+
\newcommand{\pandocbounded}[1]{#1}
% pandoc puts lists in 'tightlist' command when no space between bullet points in Rmd file,
% so we add this command to the template
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
 
% allow us to include code blocks in shaded environments
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}

% set white space before and after code blocks


\renewenvironment{Shaded}
{
  \vspace{10pt}%
  \begin{snugshade}%
}{%
  \end{snugshade}%
  \vspace{8pt}%
}

% User-included things with header_includes or in_header will appear here
% kableExtra packages will appear here if you use library(kableExtra)
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{xcolor}


%UL set section header spacing
\usepackage{titlesec}
% 
\titlespacing\subsubsection{0pt}{24pt plus 4pt minus 2pt}{0pt plus 2pt minus 2pt}


%UL set whitespace around verbatim environments
\usepackage{etoolbox}
\makeatletter
\preto{\@verbatim}{\topsep=0pt \partopsep=0pt }
\makeatother


%%%%%%% PAGE HEADERS AND FOOTERS %%%%%%%%%
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\fancyhf{} % clear the header and footers
\pagestyle{fancy}
\renewcommand{\chaptermark}[1]{\markboth{\thechapter. #1}{\thechapter. #1}}
\renewcommand{\sectionmark}[1]{\markright{\thesection. #1}} 
\renewcommand{\headrulewidth}{0pt}

\fancyhead[LO]{\emph{\leftmark}} 
\fancyhead[RE]{\emph{\rightmark}} 




% UL page number position 
\fancyfoot[C]{\emph{\thepage}} %regular pages
\fancypagestyle{plain}{\fancyhf{}\fancyfoot[C]{\emph{\thepage}}} %chapter pages




%%%%% SELECT YOUR DRAFT OPTIONS
% This adds a "DRAFT" footer to every normal page.  (The first page of each chapter is not a "normal" page.)
\fancyfoot[C]{\emph{DRAFT on \today}}

% IP feb 2021: option to include line numbers in PDF

% for line wrapping in code blocks
\usepackage{fancyvrb}
\usepackage{fvextra}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{breaklines=true, breakanywhere=true, commandchars=\\\{\}}

% for quotations -- loaded here rather than in ociamthesis.cls, as it needs to
% be loaded after fvextra, otherwise we get a warning message
\usepackage{csquotes}

% This highlights (in blue) corrections marked with (for words) \mccorrect{blah} or (for whole
% paragraphs) \begin{mccorrection} . . . \end{mccorrection}.  This can be useful for sending a PDF of
% your corrected thesis to your examiners for review.  Turn it off, and the blue disappears.
\correctionstrue


%%%%% BIBLIOGRAPHY SETUP
% Note that your bibliography will require some tweaking depending on your department, preferred format, etc.
% If you've not used LaTeX before, I recommend just using pandoc for citations -- this is what's used unless you specific e.g. "citation_package: natbib" in index.Rmd
% If you're already a LaTeX pro and are used to natbib or something, modify as necessary.

% this allows the latex template to handle pandoc citations
% definitions for citeproc citations
\NewDocumentCommand\citeproctext{}{}
\NewDocumentCommand\citeproc{mm}{%
\begingroup\def\citeproctext{#2}\cite{#1}\endgroup}
\makeatletter
% allow citations to break across lines
\let\@cite@ofmt\@firstofone
% avoid brackets around text for \cite:
\def\@biblabel#1{}
\def\@cite#1#2{{#1\if@tempswa , #2\fi}}
\makeatother
\newlength{\cslhangindent}
\setlength{\cslhangindent}{1.5em}
\newlength{\csllabelwidth}
\setlength{\csllabelwidth}{3em}
\newenvironment{CSLReferences}[2] % #1 hanging-indent, #2 entry-spacing
{\begin{list}{}{%
	\setlength{\itemindent}{0pt}
	\setlength{\leftmargin}{0pt}
	\setlength{\parsep}{0pt}
	% turn on hanging indent if param 1 is 1
	\ifodd #1
	\setlength{\leftmargin}{\cslhangindent}
	\setlength{\itemindent}{-1\cslhangindent}
	\fi
	% set entry spacing
	\setlength{\itemsep}{#2\baselineskip}}}
{\end{list}}
\usepackage{calc}
\newcommand{\CSLBlock}[1]{\hfill\break\parbox[t]{\linewidth}{\strut\ignorespaces#1\strut}}
\newcommand{\CSLLeftMargin}[1]{\parbox[t]{\csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLRightInline}[1]{\parbox[t]{\linewidth - \csllabelwidth}{\strut#1\strut}}
\newcommand{\CSLIndent}[1]{\hspace{\cslhangindent}#1}




% Uncomment this if you want equation numbers per section (2.3.12), instead of per chapter (2.18):
%\numberwithin{equation}{subsection}


%%%%% THESIS / TITLE PAGE INFORMATION
% Everybody needs to complete the following:
\title{Extending Whole Program CFA for Integrity}
\author{Pratyush Choudhary}
\college{Indian Institute of Technology Gandhinagar}

% Master's candidates who require the alternate title page (with candidate number and word count)
% must also un-comment and complete the following three lines:

% Uncomment the following line if your degree also includes exams (eg most masters):
%\renewcommand{\submittedtext}{Submitted in partial completion of the}
% Your full degree name.  (But remember that DPhils aren't "in" anything.  They're just DPhils.)
\degree{Master of Technology}

% Term and year of submission, or date if your board requires (eg most masters)
\degreedate{May 2025}


%%%%% YOUR OWN PERSONAL MACROS
% This is a good place to dump your own LaTeX macros as they come up.

% To make text superscripts shortcuts
\renewcommand{\th}{\textsuperscript{th}} % ex: I won 4\th place
\newcommand{\nd}{\textsuperscript{nd}}
\renewcommand{\st}{\textsuperscript{st}}
\newcommand{\rd}{\textsuperscript{rd}}

%%%%% THE ACTUAL DOCUMENT STARTS HERE
\begin{document}

%%%%% CHANGE TO LEFT-ALIGNED
\RaggedRight

%%%%% CHOOSE YOUR LINE SPACING HERE
% This is the official option.  Use it for your submission copy and library copy:
\setlength{\textbaselineskip}{20pt plus2pt}
% This is closer spacing (about 1.5-spaced) that you might prefer for your personal copies:
%\setlength{\textbaselineskip}{18pt plus2pt minus1pt}

% You can set the spacing here for the roman-numbered pages (acknowledgements, table of contents, etc.)
\setlength{\frontmatterbaselineskip}{17pt plus1pt minus1pt}

% UL: You can set the line and paragraph spacing here for the separate abstract page to be handed in to Examination schools
\setlength{\abstractseparatelineskip}{13pt plus1pt minus1pt}
\setlength{\abstractseparateparskip}{0pt plus 1pt}

% UL: You can set the general paragraph spacing here - I've set it to 2pt (was 0) so
% it's less claustrophobic
\setlength{\parskip}{2pt plus 1pt}

%
% Customise title page
%
\def\crest{{\includegraphics[width=5cm]{templates/iitgnlogo.png}}}
\renewcommand{\university}{}
\renewcommand{\submittedtext}{A thesis submitted in partial fulfillment of the requirements for the degree of}
\renewcommand{\thesistitlesize}{\fontsize{22pt}{28pt}\selectfont}
\renewcommand{\gapbeforecrest}{25mm}
\renewcommand{\gapaftercrest}{25mm
}


% Leave this line alone; it gets things started for the real document.
\setlength{\baselineskip}{\textbaselineskip}


%%%%% CHOOSE YOUR SECTION NUMBERING DEPTH HERE
% You have two choices.  First, how far down are sections numbered?  (Below that, they're named but
% don't get numbers.)  Second, what level of section appears in the table of contents?  These don't have
% to match: you can have numbered sections that don't show up in the ToC, or unnumbered sections that
% do.  Throughout, 0 = chapter; 1 = section; 2 = subsection; 3 = subsubsection, 4 = paragraph...

% The level that gets a number:
\setcounter{secnumdepth}{2}
% The level that shows up in the ToC:
\setcounter{tocdepth}{1}


%%%%% ABSTRACT SEPARATE
% This is used to create the separate, one-page abstract that you are required to hand into the Exam
% Schools.  You can comment it out to generate a PDF for printing or whatnot.

% JEM: Pages are roman numbered from here, though page numbers are invisible until ToC.  This is in
% keeping with most typesetting conventions.
\begin{romanpages}

% Title page is created here
\maketitle

%%%%% DEDICATION

%%%%% ACKNOWLEDGEMENTS


\begin{acknowledgements}
 	This is where you will normally thank your advisor, colleagues, family and friends, as well as funding and institutional support. In our case, we will give our praises to the people who developed the ideas and tools that allow us to push open science a little step forward by writing plain-text, transparent, and reproducible theses in R Markdown.

 We must be grateful to John Gruber for inventing the original version of Markdown, to John MacFarlane for creating Pandoc (\url{http://pandoc.org}) which converts Markdown to a large number of output formats, and to Yihui Xie for creating \texttt{knitr} which introduced R Markdown as a way of embedding code in Markdown documents, and \texttt{bookdown} which added tools for technical and longer-form writing.

 Special thanks to \href{http://chester.rbind.io}{Chester Ismay}, who created the \texttt{thesisdown} package that helped many a PhD student write their theses in R Markdown. And a very special thanks to John McManigle, whose adaption of Sam Evans' adaptation of Keith Gillow's original maths template for writing an Oxford University DPhil thesis in LaTeX provided the template that I in turn adapted for R Markdown.

 Finally, profuse thanks to JJ Allaire, the founder and CEO of \href{http://rstudio.com}{RStudio}, and Hadley Wickham, the mastermind of the tidyverse without whom we'd all just given up and done data science in Python instead. Thanks for making data science easier, more accessible, and more fun for us all.

 \begin{flushright}
 Ulrik Lyngs \\
 Linacre College, Oxford \\
 2 December 2018
 \end{flushright}
\end{acknowledgements}



%%%%% ABSTRACT


\renewcommand{\abstracttitle}{Abstract}
\begin{abstract}
	This \emph{R Markdown} template is for writing an Oxford University thesis. The template is built using Yihui Xie's \texttt{bookdown} package, with heavy inspiration from Chester Ismay's \texttt{thesisdown} and the \texttt{OxThesis} \LaTeX~template (most recently adapted by John McManigle).

This template's sample content include illustrations of how to write a thesis in R Markdown, and largely follows the structure from \href{https://ulyngs.github.io/rmarkdown-workshop-2019/}{this R Markdown workshop}.

Congratulations for taking a step further into the lands of open, reproducible science by writing your thesis using a tool that allows you to transparently include tables and dynamically generated plots directly from the underlying data. Hip hooray!
\end{abstract}



%%%%% MINI TABLES
% This lays the groundwork for per-chapter, mini tables of contents.  Comment the following line
% (and remove \minitoc from the chapter files) if you don't want this.  Un-comment either of the
% next two lines if you want a per-chapter list of figures or tables.
\dominitoc % include a mini table of contents

% This aligns the bottom of the text of each page.  It generally makes things look better.
\flushbottom

% This is where the whole-document ToC appears:
\tableofcontents

\listoffigures
	\mtcaddchapter
  	% \mtcaddchapter is needed when adding a non-chapter (but chapter-like) entity to avoid confusing minitoc

% Uncomment to generate a list of tables:
\listoftables
  \mtcaddchapter
%%%%% LIST OF ABBREVIATIONS
% This example includes a list of abbreviations.  Look at text/abbreviations.tex to see how that file is
% formatted.  The template can handle any kind of list though, so this might be a good place for a
% glossary, etc.
% First parameter can be changed eg to "Glossary" or something.
% Second parameter is the max length of bold terms.
\begin{mclistof}{List of Abbreviations}{3.2cm}

\item[1-D, 2-D]

One- or two-dimensional, referring \textbf{in this thesis} to spatial dimensions in an image.

\item[Otter]

One of the finest of water mammals.

\item[Hedgehog]

Quite a nice prickly friend.

\end{mclistof} 


% The Roman pages, like the Roman Empire, must come to its inevitable close.
\end{romanpages}

%%%%% CHAPTERS
% Add or remove any chapters you'd like here, by file name (excluding '.tex'):
\flushbottom

% all your chapters and appendices will appear here
\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{\# this line ensures that tinytex doesn\textquotesingle{}t try to update LaTeX packages on every single knit}
\FunctionTok{options}\NormalTok{(}\AttributeTok{tinytex.tlmgr\_update =} \ConstantTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\chapter*{Introduction}\label{introduction}
\addcontentsline{toc}{chapter}{Introduction}

\adjustmtc
\markboth{Introduction}{}

\chapter{Background}\label{background}

\minitoc 

There are digital devices all around us running code written by people. It can be
to handle a simple electric toothbrush's timer, or to move a robot arm for a surgery.
And, all programs are not created equal. Some are mission-critical pieces of code that
may require high levels of scrutiny at each step of creation, lest they fail and
result in disasters - financial or otherwise.

For such a program running on a device, we need to ensure that it ran correctly
(meaning - as intended by the logic of the code).
But just writing ``good'' code doesn't save it from other factors that are present while running it.
There are a few factors that may influence the program to not behave correctly:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  A bug in the code that slipped past the review process.
\item
  There's a flaw in the device that the code is running on.
\item
  A malicious actor attacks the device/program to modify the execution.
\item
  The device's environment is adversarial. Eg. A nuclear plant's control panel.
\end{enumerate}

For factors 1-2, there are techniques like source code auditing, testing,
fuzzing, static and dynamic program analysis, and formal verification that try
to minimize the software/hardware bugs {[}\citeproc{ref-godefroid2012sage}{28}, \citeproc{ref-kern1999formal}{34}, \citeproc{ref-luk2005dynamic}{39}--\citeproc{ref-artoftesting}{41}, \citeproc{ref-quinlan2009source}{44}{]}.

For factor 3, there are various types of results that are possible ranging from
Denial of Service to Information Leak.
Our focus is on preventing the control flow (the order of instructions that run for a given input)
of the program from changing, and for that, the techniques come under the term
Control Flow Integrity (CFI) {[}\citeproc{ref-sok}{5}{]}.

But what if the adversary is the device's environment like factor 4?
Or what do we do about the fact that we still cannot guarantee that the program is secure?
As stated by Bruce Schneier: Security is a process, not a product {[}\citeproc{ref-bruceessay}{47}{]}.
No system is fully secure, and security flaws are inevitable.
We need to at-least be able to prove in some way that the program behaved as intended.

For simple programs that process an input to give a deterministic output like
counting prime numbers or calculators, it is easy to just verify the output.
But for non-deterministic or complex programs with side-effects (changes to the
system or device - like writing to a file, or moving a robot arm), verifying the
output is not feasible. One way is to instrument the system to check that the
control flow of the program is as expected, which in turn may indicate
that the program ran correctly.
And the set of techniques for this instrumentation is called Control Flow
Attestation (CFA).

\section{Control Flow Techniques}\label{control-flow-techniques}

Let us now look at both CFI and CFA techniques in detail to know their aims and the current
capabilities afforded to us by them.

\subsection{CFI}\label{cfi}

\subsubsection{What and why?}\label{what-and-why}

When the program executes, it goes through a sequence of instructions. The order
of these instructions is determined by various factors including the input, current state,
and some decisions like if-else statements. That order is called the control flow
of the program, literally how the control of the program flows through the instructions.
If attackers try to modify how the program behaves, and run instructions
of their choosing, they modify the control flow of the program. And this type of attack is
called control-flow hijacking attack.
The set of techniques to provide integrity against these attacks is CFI.

\subsubsection{History and Techniques used}\label{history-and-techniques-used}

There are 3 main types of attacks that can change the control flow of a program {[}\citeproc{ref-sok}{5}{]}:

\begin{itemize}
\tightlist
\item
  Code injection: Attacker puts their own arbitrary code into the memory of the program and runs it.
\item
  Code reuse: Attacker uses the instructions already present in the program to execute operations.
\item
  Data manipulation: Attacker changes the data used to take decisions for the control flow.
\end{itemize}

To mitigate against execution of attacker controlled code, the common practice is
to add Data Execution Prevention (DEP) mechanisms. All parts of program memory except
(read-only) code sections are marked as non executable, so any injected code would not be executable.

Code reuse attacks then try to bypass DEP by using the existing code in memory to
execute arbitrary operations. The way to do that would be by changing the control
flow in a way that jumps between chosen code snippets. These attacks are called
Return-oriented programming (ROP) and Jump-oriented programming (JOP).
Some of the mitigations are Address Space Layout Randomization (ASLR),
Shadow Stacks, Stack Canaries, Pointer Authentication, and Branch Target Identification.
We'll discuss ROP/JOP with Pointer Authentication and Branch Target
Identification as their ARM implementations later on in section \hyperref[arm-specifics]{1.2 - ARM Specifics}.

Data manipulation attacks focus on changing the values of variables to change the control flow.
They have their own set of techniques countering and detecting the attacks called
Data Flow Integrity (DFI) and Data Flow Attestation (DFA). But they are complementary
but out of scope for us right now. Our focus will be on Code reuse attacks instead.

CFI was originally proposed by Abadi et al.{[}\citeproc{ref-abadi2009control}{1}{]} as a policy-based mitigation
against control flow hijacking attacks by restricting the execution of a program
to a pre-computed Control Flow Graph (CFG) {[}\citeproc{ref-sok}{5}{]}. This CFG could be statically or
dynamically generated, and a close approximation of the CFG would make it harder
for an attacker to manipulate the control flow as they want.

\subsection{CFA}\label{cfa}

\subsubsection{Why?}\label{why}

As noted previously, analysis, testing and even adding CFI doesn't mean the program is secure.
Also, there are many use-cases where we need an unforgeable evidence of the control flow
of a given program. For example, in a syringe pump, where this evidence could be
needed by hospital and insurance that it indeed delivered the given dosage and correctly at that.
This can be achieved by path attestation, where the verifier gets a non-repudiable
proof of execution on prover for the given input.
Path attestation also acts as a lighter alternative to verifiable computation {[}\citeproc{ref-walfish2015verifying}{54}{]}.

There are other integrity measurements too that can attest to various properties
of the system being tested.
Like, weather the system satisfies certain properties {[}\citeproc{ref-chen2006protocol}{21}, \citeproc{ref-chen2008property}{22}, \citeproc{ref-kil2009remote}{35}, \citeproc{ref-sadeghi2004property}{46}{]},
it booted up with particular software stack {[}\citeproc{ref-arbaugh1997secure}{6}, \citeproc{ref-gasser1989digital}{27}{]},
or that it executed certain operations correctly {[}\citeproc{ref-sun2020oat}{52}{]}.

The work done on CFA has been parallel to CFI, but with an aligned objective {[}\citeproc{ref-sok}{5}{]}.
We will focus on path attestation, and whole program path in particular.
The reason for that is explained later in CFA - Techniques subsection.

\subsubsection{General Overview of the process}\label{general-overview-of-the-process}

\begin{figure}[H]

{\centering \includegraphics[width=0.5\linewidth]{./imgs/placeholder-cfa-workflow} 

}

\caption{Typical CFA Interaction}\label{fig:cfa-workflow}
\end{figure}

For CFA, the general workflow has 2 separate agents, a prover (Prv) and a remote verifier (Vrf).
The Vrf sends a request to Prv with a cryptographic challenge (Eg. a \emph{nonce}).
As a response to the challenge, Prv executes the program with the given
input (either implicitly or explicitly given in the request).
It then generates a report of execution (CFreport), and sends it to Vrf.
This CFreport is signed using the challenge sent by Vrf, and contains the output of the program and an
authenticated log (CFlog) of the control flow taken by the program during execution.

\emph{But how would the Vrf know that Prv has not forged the report?}
This is where a Root of Trust (RoT) comes in.
A Root of Trust (RoT) is a part of the system that we essentially \emph{trust} to work
properly even in adversarial conditions. This trust in the mechanism is assumed and not derived.
It then serves as the foundation on which the rest of the security guarantees
of the system can be derived. Commonly, systems have Trusted Execution Environments
(TEE) like Intel SGX {[}\citeproc{ref-intel-sgx}{33}{]} or ARM TrustZone {[}\citeproc{ref-armtz}{7}{]} that act as the RoT.

In our case, it's a piece of hardware on Prv that monitors the system, validates its state,
and generates the CFlog and CFreport that's sent to Vrf.

When Vrf recieves CFreport, it uses it to determine whether the program was executed as expected by Prv.
It does so by checking if CFlog contains a valid control flow of the program
for the input. If the path is invalid, Vrf can also analyze CFlog to detect
deviations and determine the cause.

\subsubsection{Techniques used}\label{cfatechniques}

Remote attestation to establish memory content integrity has been explored previously
in various domains {[}\citeproc{ref-abera2019diat}{3}, \citeproc{ref-asokan2015seda}{14}, \citeproc{ref-fraser2004copilot}{26}, \citeproc{ref-li2011viper}{37}, \citeproc{ref-sun2020oat}{52}{]}.
As TEEs were generally historically unavailable on low-end embedded devices,
software based attestation techniques like SWATT {[}\citeproc{ref-seshadri2004swatt}{49}{]} and
PIONEER {[}\citeproc{ref-seshadri2005pioneer}{48}{]} were proposed.
They implemented software based self-checksum functions as a means of attestation.
They relied on precise timing measurements, and were applicable only in settings where
comunnication delay between Vrf and Prv is deterministic.

Then there are Hybrid attestation techniques, that aim to minimize changes to
underlying hardware, while giving same guarantees as hardware-based techniques.
VRASED {[}\citeproc{ref-nunes2019vrased}{42}{]} adds integrity checks in software, while using trusted hardware to control the checks.

But these techniques measure the state of Prv only when remote attestation is executed.
They are oblivious to program's state between two consecutive measurements, or
information of program before measurements. That means they suffer from
time-of-check to time-of-use (TOCTOU) attacks. There are proposed designes that
avoid this limitation {[}\citeproc{ref-de2021toctou}{24}{]}.

Works in path attestation, where the control flow path of the program is recorded
for the proof, include CFLAT {[}\citeproc{ref-abera2016cflat}{2}{]} and OAT {[}\citeproc{ref-sun2020oat}{52}{]}.
We will focus on these two, as they can represent the main approaches to path
attestation, and other works have essentially similar methods {[}\citeproc{ref-abera2016cflat}{2}, \citeproc{ref-abera2019diat}{3}, \citeproc{ref-dessouky2018litehax}{25}, \citeproc{ref-huo2020lape}{30}, \citeproc{ref-nunes2021tiny}{43}, \citeproc{ref-sun2020oat}{52}, \citeproc{ref-toffalini2019scarr}{53}, \citeproc{ref-zhang2021recfa}{57}{]}.

CFLAT computes the hash of basic blocks by adding instrumentation at their end,
and then accumulates their hash which represents the execution path of the program.
The Vrf then compares it with historically collected expected hashes for known
execution paths.
OAT on the other hand, adds instrumentation after conditionals, which signifies
the direction the branches took. This, leads to less instrumentation compared to
CFLAT where every edge of the CFG is instrumented.
This information is saved in the TEE in the form of a bit-trace, along with
jump, call, and return addresses.
The Vrf then uses the bit trace and other values to perform a symbolic execution
of the program for verification.
Their instrumentation approaches for the CFG of a program
are shown in figure \ref{fig:cflat-oat-instruments}.
\sethlcolor{pink}\hl{Add cflat-oat-instruments.png}\sethlcolor{correctioncolor}

CFLAT and OAT have logging events for each Conditional Branch, Indirect function call, and Function exit.
Additionally, CFLAT also have events for Unconditional Branches and Direct function calls.
All of these events has a domain transition to TEE for logging. Which, when large codebases
are taken in account, can become a performace bottleneck due to the sheer number of them {[}\citeproc{ref-blast}{55}{]}.

\sethlcolor{pink}\hl{?? TABLE}\sethlcolor{correctioncolor} describes the number of TEE domain switches at runtime,
as seen for CFLAT and OAT for Embench-IOT benchmarks, when applied to whole programs.
It also shows the amount of extensive instrumentation that is needed for path attestation.
Despite such intrusive amount of instrumentation, which also translates into
a proportional number of domain switches, CFLAT and OAT report fairly low runtime overheads.
CFLAT reports runtime overhead in seconds when evaluated on a syringe pump application.
OAT reports an average runtime overhead of 2.7\% on 5 embedded applications.

This low overhead for both can be explained by the fact that their application
has been to small programs or ``operations'' that span a few thousand control-flow events.
When applied to whole programs, the overhead turns out to be more than 1000x {[}\citeproc{ref-blast}{55}{]}.
This means, a program that takes a few seconds would take hours to complete.
Other previous works, like CFLAT and OAT, have mostly been applied to small
programs or to programs that work in specialized environments {[}\citeproc{ref-abera2016cflat}{2}, \citeproc{ref-dessouky2018litehax}{25}, \citeproc{ref-nunes2021tiny}{43}, \citeproc{ref-toffalini2019scarr}{53}, \citeproc{ref-blast}{55}{]}.
Prior work has also shown that a Vrf can miss attacks that are directed against
a program when paths in only some parts of it are attested {[}\citeproc{ref-hu2019probability}{29}{]}.
Therefore, it's better for Vrf to be able to attest the entire execution of a program.

BLAST {[}\citeproc{ref-blast}{55}{]} was then proposed, which overcame the limitations of CFLAT and OAT while
also adding whole program control flow attestation capabilities. It's discussed
in detail later on in Primary Works - \hyperref[blast]{1.3.1 BLAST} subsection.

Also, most CFA techniques do not guarantee that the report will be recieved by Vrf.
The Vrf may not trust the output recieved by it unless CFlog is attached to it,
runtime auditing {[}\citeproc{ref-caulfield2024traces}{19}, \citeproc{ref-caulfield2023acfa}{20}{]} aims to bridge that
gap and reliably deliver CFlog even when Prv turns malicious and tries to not
follow the protocol.

\section{ARM Specifics}\label{arm-specifics}

Now that we know what CFI and CFA are, we can take a look at platform specific solutions.
For this work, we choose ARM as it's common in embedded applications,
which is a popular use-case where CFI and CFA techniques are often applied {[}\citeproc{ref-sok}{5}{]}.

Before diving into the implementation details, we'll first discuss the ARM Architecture
(ARMv8-A specifically) and its calling conventions to brush up the required background knowledge.
We'll also discuss some architecture level features that can be used for CFI and CFA.

\subsection{ARM Assembly Basics}\label{arm-assembly-basics}

We will only focus on AArch64, the 64-bit instruction set, and on the ARMv8-A
and later profiles {[}\citeproc{ref-arm-arch-manual}{11}{]}.

\subsubsection{Registers}\label{registers}

Let us first talk about Registers.
SIMD, floating point and vector registers will be excluded in this section for brevity.

In AArch64, the available registers are {[}\citeproc{ref-armasm-user-guide}{8}, \citeproc{ref-arm-isa}{10}{]}:

\begin{itemize}
\tightlist
\item
  31 64-bit general-purpose registers \texttt{x0\ -\ x30} which can hold any type of data.
  They usually hold integers and addresses, but anything with length of 64-bits
  can be stored in them. Their lower 32-bits can also be accessed and used as
  32-bit registers by using \texttt{wN} instead of \texttt{xN}, where \texttt{N} is the register number.
\item
  1 Program Counter \texttt{PC}.
\item
  1 Process State \texttt{PSTATE}.
\item
  \texttt{wzr/xzr} called zero register,
  which reads \texttt{0} and ignores the writes. Therefore it's only useful as a source.
  It doesn't represent a real register on chip,
  but it's just a symbol for ``assume value of operand to be zero''.
\item
  4 stack pointer registers \texttt{SP\_EL0\ -\ SP\_EL3}.
\item
  3 exception link registers \texttt{ELR\_EL1\ -\ ELR\_EL3}.
\item
  3 saved program status registers \texttt{SPSR\_EL1\ -\ SPSR\_EL3}. They are 32-bit wide only,
  unlike other registers.
\end{itemize}

There is no register \texttt{w31/x31}. Depending on instructions, the register number \texttt{31}
either represents the zero register or the stack pointer.

Depending on the Exception Level or privileged execution mode,
the Stack Pointer \texttt{SP} is represented by the corresponding \texttt{SP\_EL} register.

As we are talking about user level code (\texttt{EL0}) only, we will ignore the \texttt{ELR} and \texttt{SPSR}
registers, and consider \texttt{SP\_EL} registers to just be \texttt{SP}.

The registers and their usage are as follows {[}\citeproc{ref-armasm-user-guide}{8}, \citeproc{ref-arm-isa}{10}, \citeproc{ref-arm-pcs}{12}{]}:

\begin{itemize}
\tightlist
\item
  \texttt{x0} to \texttt{x7}:\\
  (Volatile) For passing arguments and return values for system and function calls.
  Additional arguments are stored on the stack.
  The return value is typically stored in \texttt{x0}. Caller assumes they will be modified.
\item
  \texttt{x8}:\\
  (Volatile) Indirect result location register. It is also typically used for holding
  syscall number.
\item
  \texttt{x9} to \texttt{x15}:\\
  (Volatile) General purpose, for storing temporary data. Caller saved.
\item
  \texttt{x16} and \texttt{x17}:\\
  (Volatile) Intra-procedure-call registers. Used as scratch
  registers by system linker during calls.
\item
  \texttt{x18}:\\
  Reserved for platform specific use. Usage is avoided for portability.
\item
  \texttt{x19} to \texttt{x28}:\\
  (Non-volatile) Callee-saved registers. They must be preserved across calls.
  If used, the callee must push the values to the stack at the beginning of function,
  and restore them before returning.
\item
  \texttt{x29} (Frame Pointer \texttt{FP}):\\
  (Non-volatile) Points to the start of the stack frame of a function.
\item
  \texttt{x30} (Link Register \texttt{LR}):\\
  (Non-volatile) Holds the return address of a function call.
  Can be used, but value must be restored before returning.
\item
  \texttt{SP} (Stack Pointer):\\
  Special Register. Points to the top of the stack.
  Can be used as base address register for loads and stores.
\item
  \texttt{PC} (Program Counter):\\
  Special Register. Cannot be accessed explicitly.
  Holds the address of the next instruction to be executed.
\item
  \texttt{PSTATE}:\\
  Holds the various status and control flags for the processor.
  They include Execution State, Interrupt Mask Bits, Processor Mode, Condition Flags,
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\emph{Sidenote:} XNU (Apple iOS and MacOS) ABI's conventions differ from the aforementioned one.
Although private and undocumented, it can be seen from the source {[}\citeproc{ref-apple-oss}{31}{]} that
the main differences (as of 02 May 2025) are {[}\citeproc{ref-so-xnu-abi}{50}{]}:

\begin{itemize}
\tightlist
\item
  The immidiate value passed to \texttt{svc} instruction is ignored. \texttt{svc\ 0x80} is used
  by the std library, which invokes a single handler.
\item
  The register used for syscalls is \texttt{x16} instead of \texttt{x8}.
\item
  The arguments are in \texttt{x0} through \texttt{x8} registers, supporting upto 9 arguments.
  This is only used if there's an indirect syscall i.e.~\texttt{x16\ =\ 0}.
\item
  Stack is not used for passing arguments.
\item
  \texttt{x0} and \texttt{x1} can hold 2 return values. For example in case of \texttt{fork}.
\item
  Error is reported using the carry bit, in which case \texttt{x0} would hold
  the error code.
\item
  Syscall numbers can be \emph{negative}.
  UNIX ones are non-negative as usual, ranging between \texttt{0} and \texttt{557}.
  Mach ones are negative with range between \texttt{-10} and \texttt{-100}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\subsubsection{Calling (and Branching) Conventions}\label{calling-and-branching-conventions}

Now that we know the details about the registers, their usage and their volatility for a caller,
we can look at how functions are called in ARM architecture.

The main difference here from \texttt{x86-64} ISA is that we don't have a \texttt{call} instruction.
Instead branching instructions are used for conditionals, loops, and procedure calls.
We mainly have 5 types of Branching instructions:

\begin{itemize}
\tightlist
\item
  \texttt{B\ label} (Branch):\\
  Unconditional branch to a label within \texttt{PC} \(\pm\) \texttt{128MiB}.
  Not a subroutine call or return.
\item
  \texttt{B.cond\ label} (Branch Conditionally):\\
  Conditional branch to label within \texttt{PC} \(\pm\) \texttt{1MiB}.
  Not a subroutine call or return.
\item
  \texttt{BL\ label} (Branch with Link):\\
  Unconditional branch to label in range \(\pm\) \texttt{128MiB},
  and store the return address (\texttt{PC+4}) in \texttt{x30}.
  It is a subroutine call.
\item
  \texttt{BR\ xN}(Branch to Register):\\
  Unconditional branch to address in register \texttt{xN}.
  It is not a subroutine return.
\item
  \texttt{BLR\ xN} (Branch with Link to Register):\\
  Unconditional branch to address in register \texttt{xN},
  and store return address (\texttt{PC+4}) in \texttt{x30}.
  It is a subroutine call.
\end{itemize}

There are many other branching instructions too, like \texttt{CBZ}, \texttt{TBZ} etc.
but they are not relevant for us.

Now, we get 2 types of functions:

\begin{itemize}
\tightlist
\item
  \emph{Non-leaf} - Functions that call other functions.
\item
  \emph{Leaf} - Functions that don't have any function calls in their body, and simply return.
\end{itemize}

\emph{Why is it relevant?}
Because subroutine calls would use \texttt{BL}/\texttt{BLR} instructions,
and store the return address in \texttt{x30} {[}\citeproc{ref-arm-arch-manual}{11}{]}.
We don't need to worry about Leaf functions,
but what about nested Non-leaf function calls? \texttt{x30} would get overwritten.\\
To prevent that from happening, we make the distinction, and treat them differently.
For Non-leaf functions, we simply save the value in \texttt{x30} at the start of the function,
and restore it before return. It looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{foo:}
\NormalTok{  ...     }\CommentTok{; save x30}
\NormalTok{  ...}
\NormalTok{  bl bar  }\CommentTok{; call bar}
\NormalTok{  ...}
\NormalTok{  ...     }\CommentTok{; restore x30}
  \ControlFlowTok{ret}

\FunctionTok{bar:}
\NormalTok{  ...     }\CommentTok{; save x30}
\NormalTok{  ...}
\NormalTok{  bl baz  }\CommentTok{; call baz}
\NormalTok{  ...}
\NormalTok{  ...     }\CommentTok{; restore x30}
  \ControlFlowTok{ret}

\FunctionTok{baz:}
\NormalTok{  ...}
  \ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

\begin{quote}
\texttt{foo} and \texttt{bar} are non-leaf functions, whereas \texttt{baz} is a leaf function.
\end{quote}

\subsection{Pointer Authentication Code (PAC)}\label{pac-bg}

Pointer Authentication was added in ARMv8.3-A under the mandatory feature \texttt{FEAT\_PAuth} {[}\citeproc{ref-arm-feat-names}{13}{]}.
To understand PAC, we must first understand why and what does it aim to fix.

\subsubsection{Return Oriented Programming (ROP)}\label{return-oriented-programming-rop}

We have discussed how arbitrary code execution can be prevented.
This means that attackers can't inject and use arbitrary code, but what is stopping
them from using existing application code? Many applications are huge in size,
and that means there is a lot of code that has execute permissions already.
The attackers can analyze the application, and find out gadgets. Gadgets are executable
fragments of code, usually ending with a return. For example:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{...}
\BuiltInTok{add}\NormalTok{ x0}\OperatorTok{,}\NormalTok{ x1}\OperatorTok{,}\NormalTok{ x2}
\ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

The attackers can then chain these gadgets together to form and execute their malicious code.
Any library that is in the address space of the process is a potential source of gadgets.
For example, GLIBC on ARM64, has almost 16,000 usable gadgets {[}\citeproc{ref-riscyrop}{23}{]}.
The ROP exploit process is described in figure \ref{fig:rop-diag}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-rop} 

}

\caption{Using ROP Gadgets}\label{fig:rop-diag}
\end{figure}

Although the process of finding and chaining the process is hard, it can be automated.
ASLR can make the process harder, but it is still possible to carry out ROP attacks using
Automated Exploit Generation (AEG) tools or information disclosure {[}\citeproc{ref-aeg2014}{15}, \citeproc{ref-riscyrop}{23}{]}.

\subsubsection{Solution?}\label{solution}

ROP exploits the fact that the return address is not checked, and can be used to
jump to next gadget instead. What if we check the return address for corruption
before using it? One way is using stack canaries, but even those can be bypassed
by memory disclosure vulnerabilities.

What if we sign the \texttt{LR}? The attacker would need a correctly signed address to replace it,
increasing the difficulty of exploit generation.
That's exactly what PAC does. Pointer Authentication
takes advantage of the fact that pointers are 64-bit long, but not all 64-bits
are needed to represent the virtual memory address.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-pac-bits} 

}

\caption{Pointer Layout on ARM64}\label{fig:pac-bits}
\end{figure}

PAC uses the top bits of the pointer to store a signature of the pointer
(as shown in fig \ref{fig:pac-bits}), and they aren't
used as a part of the address. At the start of the function, the \texttt{LR} is signed.
Then just before the return, the address is authenticated using PAC. If the check fails,
an exception is raised. Now, to perform a ROP attack, the attacker needs gadget addresses
(made harder with ASLR), and have properly signed pointers to those addresses.
To get a signed pointer, they would need to access a signing gadget.

After adding the PAC instructions, a function would look like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{foo:}
\NormalTok{  paciasp}
\NormalTok{  ...}
\NormalTok{  autiasp}
  \ControlFlowTok{ret}
\end{Highlighting}
\end{Shaded}

\emph{Note:} If we don't need backwards compatibility, we can use \texttt{RETAA} which is equivalent to \texttt{AUTIASP\ +\ RET}.

\subsubsection{Using NOP space}\label{using-nop-space}

A subset of the PAC instructions are in the NOP-space. That means, if a
library or application uses the NOP-space instructions to add PAC support,
they can still run on old processors that do not support PAC features.
The instruction would just be treated as a \texttt{NOP}.
This is accomplished by encoding the instructions as ``hints'' to the processor.
These include: \texttt{AUTIx1716}, \texttt{AUTIxSP}, \texttt{AUTIxZ}, \texttt{PACIx1716}, \texttt{PACIxSP}, \texttt{PACIxZ} and \texttt{XPACLRI}.
Where (lower) \texttt{x} is either \texttt{A} or \texttt{B} depending on the key to be used {[}\citeproc{ref-sipearl}{51}{]}.
More in next section on keys. There are many more instructions,
but for now we'll just talk about these NOP-space ones.

\subsubsection{Forming a PAC}\label{forming-a-pac}

ARM provides 5 128-bit keys. Each of them is stored in a pair of 64-bit system registers:

\begin{itemize}
\tightlist
\item
  2 keys, A and B, for instruction pointers
\item
  2 keys, A and B, for data pointers
\item
  1 key for general use
\end{itemize}

And these registers are only accessible in EL1 and above (refer \ref{fig:armtz-arch}).
The signature is formed by using the key, address and a modifier as shown in figure \ref{fig:pac-diag}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-pac-diag} 

}

\caption{PAC formation}\label{fig:pac-diag}
\end{figure}

The strength of PAC depends on the size of the configured virtual address.
The keys have limited life spans, that is, each time the application is launched, the keys can be rotated.
And each application can have its own independent set of keys.
The modifier should be the same for sign-authenticate instruction pair on entry/exit.
So it specifies the context in which the pointer is valid in. For example,
using \texttt{SP} as the modifier would give us a PAC that's valid only for that call of the function,
as \texttt{SP} may be different on future calls.

The attacker would need to get every pointer correct in the chain, otherwise an
exception would be raised.

\sethlcolor{pink}\hl{Results discussed in chapter 3}\sethlcolor{correctioncolor}

\subsubsection{But what do these instructions mean?}\label{but-what-do-these-instructions-mean}

\begin{itemize}
\tightlist
\item
  \texttt{AUTI} prefix is an Authenticate instruction.
\item
  \texttt{PACI} prefix is a PAC computation instruction.
\item
  \texttt{A/B} after the prefix determines the key to be used.
\item
  \texttt{1716} suffix means address is in \texttt{x17}, modifier in \texttt{x16}.
\item
  \texttt{SP} suffix means address is in \texttt{x30}, modifier is \texttt{SP}.
\item
  \texttt{Z} suffix means address is in \texttt{x30}, modifier is \texttt{0}.
\item
  \texttt{XPACLRI} is used to strip PAC from address in \texttt{x30}.
\end{itemize}

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

\emph{Sidenote:}
From ARMv9.4-A, under feature \texttt{FEAT\_PAuth\_LR}, \texttt{PACIxSPPC} and \texttt{AUTIxSPPC}
instructions were added to use \texttt{SP\ +\ PC} as the modifier to sign \texttt{LR}.
It gives better security by tying the caller and callee to the address,
and uniquely associating PAC with that particular instance of function usage.

\begin{center}\rule{0.5\linewidth}{0.5pt}\end{center}

At the end, when enabled in the codebase, PAC looks like this:
\sethlcolor{pink}\hl{Add final example of PAC}\sethlcolor{correctioncolor}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{// source}
\NormalTok{// generated asm}
\end{Highlighting}
\end{Shaded}

\subsection{Branch Target Identification (BTI)}\label{bti-bg}

Branch Target Identification was added in ARMv8.5-A under the mandatory feature \texttt{FEAT\_BTI} {[}\citeproc{ref-arm-feat-names}{13}{]}.
Let us first understand where PAC was still inadequate, and what could be improved by using BTI.

\subsubsection{Jump Oriented Programming (JOP)}\label{jump-oriented-programming-jop}

PAC could add protection against ROP attacks by adding checks to ensure a
function returns to its true caller. That is protected the returning jump points.
But what about calling jump points like indirect branches, function pointers,
and case statements? JOP attacks use these points to pivot to next gadget in
sequence instead of \texttt{RET}. So JOP gadgets would end with \texttt{BR}, \texttt{BLR} or similar instructions instead.

\texttt{BR} and similar instructions use the register to determine the jump point, which
makes it hard to determine the target statically, or that the target would be valid.
This makes it easy for the attacker to use them to execute their JOP chain.

\sethlcolor{pink}\hl{fig: JOP.png}\sethlcolor{correctioncolor}

\subsubsection{Solution?}\label{solution-1}

If it is hard to statically secure the jump points, how about the landing points?
The hijacked jumps could target arbitrary locations to pivot to.
But valid code only jumps to particular locations. So, what if those locations
can be marked as landing points, and any jump that doesn't land on them becomes invalid?

This is the idea behind BTI. The branch targets are identified and marked with \texttt{BTI}
instructions that act as landing pads. Any jump that does not land on a \texttt{BTI} instruction
generates a Branch Target Exception \footnote{\texttt{BRK,\ BTI,\ HLT,\ PACIASP} and \texttt{PACIBSP} are an exception to this.
  Refer instruction docs for details {[}\citeproc{ref-armasm-user-guide}{8}{]}.}.
Function returns are also a type of indirect branch, but they aren't required
to target the landing pads. Also, for function entry,
pointer signing instructions \texttt{PACIxSP} and \texttt{PACIxZ} act like landing pads.

The \texttt{BTI} instruction has an argument that further specifies what types of indirect branch can it be targeted by:

\begin{itemize}
\tightlist
\item
  \texttt{BTI\ c}: Indirect function calls (\texttt{BLR})
\item
  \texttt{BTI\ j}: Indirect jumps (\texttt{BR}), e.g.~case-statements
\item
  \texttt{BTI\ jc}: Indirect function calls or jumps
\end{itemize}

There are some more rules to BTI like processor states for each target instruction type.
Please refer the Sipearl Whitepaper {[}\citeproc{ref-sipearl}{51}{]}, or Arm Documentation for PAC and BTI {[}\citeproc{ref-arm-pacbti}{9}{]} for more details.

\subsubsection{NOP-space}\label{nop-space}

Instructions added under BTI are also in NOP-space, so that all applications and
libraries that use it would be backwards compatible with old processors.

\sethlcolor{pink}\hl{Results discussed in chapter 3}\sethlcolor{correctioncolor}

\sethlcolor{pink}\hl{Add BTI example here}\sethlcolor{correctioncolor}

\subsection{ARM TrustZone}\label{arm-trustzone}

\begin{figure}[H]

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-armtz} 

}

\caption{ARM TrustZone Architecture}\label{fig:armtz-arch}
\end{figure}

ARM TrustZone {[}\citeproc{ref-armtz}{7}{]} is Arm's security architecture in ARM A-profile architecture.
It provides 2 execution environments with hardware enforced isolation between them:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Normal World or Rich Execution Environment (REE) - It runs the regular software
  stack with a complex OS, hypervisor, etc. The attack surface is considered to be large,
  and the execution isn't trusted.
\item
  Trusted World/Execution Environment (TEE) - It runs a simple and small software
  stack which is assumed to be trusted. It has its own trusted services and OS.
  It also has a smaller attack surface due to its simplicity and size.
\end{enumerate}

There are 2 security states ARM architecture - Non-secure and Secure which map
to Rich and Trusted worlds respectively.
Exception levels are the levels of software execution privileges.
These mappings are specified in figure \ref{fig:armtz-arch}.
The states are often written with their exception levels like:

\begin{itemize}
\tightlist
\item
  \texttt{NS.EL2}: Non-secure state, Exception level 2
\item
  \texttt{S.EL2}: Secure state, Exception level 2
\end{itemize}

\emph{Note that EL3 is always in Secure State.}

\begin{figure}[H]

{\centering \includegraphics[width=0.75\linewidth]{./imgs/placeholder-smc-workflow} 

}

\caption{smc instruction call convention}\label{fig:smc-convention}
\end{figure}

This isolation is bridged by the usage of Secure Monitor Call (SMC) instruction.
The \texttt{smc} instruction not available in EL0 in either of the Security States.
The processes in Rich OS would call the user-space library (TEE Client),
which would in turn perform a low level call to the TrustZone driver in Rich OS.
The driver would then perform a \texttt{smc} call with arguments to the Secure Monitor.
The Secure Monitor determines the matching handler in TEE and dispatches it accordingly.
This process is shown in figure \ref{fig:smc-convention}.

\subsection{OP-TEE}\label{op-tee}

One example of a Trusted Kernel is OP-TEE. It was developed by ST-Ericsson,
and is now an open source project maintained by Linaro {[}\citeproc{ref-optee}{38}{]}.
The rich applications call OP-TEE Driver through TEE Client API. The Driver
is then responsible for the communication with the OP-TEE kernel.

\begin{figure}[H]

{\centering \includegraphics[width=0.75\linewidth]{./imgs/placeholder-optee} 

}

\caption{OP-TEE Architecture}\label{fig:optee-arch}
\end{figure}

\section{Primary Works}\label{primary-works}

\subsection{BLAST}\label{blast}

As mentioned in \hyperref[cfatechniques]{1.1.2 CFA - Techniques}, attestation has rarely targeted whole programs.
And their approaches did not scale when applied to whole program paths, mainly
due to the sheer number of domain transitions between REE/TEE {[}\citeproc{ref-blast}{55}{]}.
BLAST {[}\citeproc{ref-blast}{55}{]} was developed in 2023 with whole program paths in mind.
They took inspiration from program profiling literature to decrease the said overheads.

\subsubsection{How it works}\label{how-it-works}

It is implemented as a LLVM pass that adds instrumentation to the binary for attestation.
BLAST reserves 2 registers called \texttt{BLReg} and \texttt{LogReg} for the required instrumentation.
We'll now discuss how it uses them and tries to optimise the attestation process.

\paragraph{Local Logging:}\label{local-logging}

If we need fine-grained logging, but cannot afford the domain switches, why not log inside the REE?
BLAST does this by pre-allocating a log inside the process's address space,
and adds SFI measures discussed in \hyperref[blastsfi]{SFI} to protect its integrity.
The log is shared between REE and TEE, and its permissions are managed by the TEE.
It is then divided in 2 halves, with each half ending with a write-protected page called \texttt{sentinel\ page}.
\texttt{LogReg} is a pointer to the head of the log, and BLAST simply adds the log entry
and increments its value.

\begin{figure}[H]

{\centering \includegraphics[width=0.6\linewidth]{./imgs/placeholder-blast-pages} 

}

\caption{Structure of the log in BLAST}\label{fig:blast-log-pages}
\end{figure}

When a half is filled, \texttt{LogReg} reaches a sentinel page and a hardware fault is generated on write.
The fault handler is then executed in the TEE, which:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Makes the \texttt{LogReg} point to the other half.
\item
  Adds write-protection to the filled half, to ensure it isn't overwritten.
\item
  Commits the log's state to the TEE.
\item
  After the log is committed, it makes the half writable again.
\end{enumerate}

\paragraph{Software Fault Isolation (SFI):}\label{blastsfi}

Sentinel pages are write-protected, but what about the regular log?
Although \texttt{LogReg} is reserved, and cannot be used by other parts of the code,
simple store instructions can still modify the log value. Only the instrumentation
instructions inserted as part of the BLAST pass should be allowed to append to the log.

To ensure this, BLAST adds instrumentation after each store instruction to:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Fetch the store address and the log's address.
\item
  Check that the store address doesn't lie inside the log.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\BuiltInTok{str}\NormalTok{ w8}\OperatorTok{,} \OperatorTok{[}\NormalTok{x29}\OperatorTok{,} \OperatorTok{\#}\DecValTok{4}\OperatorTok{]}                 \CommentTok{; perform the store}
\BuiltInTok{add}\NormalTok{ x9}\OperatorTok{,}\NormalTok{ x29}\OperatorTok{,} \OperatorTok{\#}\DecValTok{4}                   \CommentTok{; obtain the store address}
\BuiltInTok{and}\NormalTok{ x9}\OperatorTok{,}\NormalTok{ x9}\OperatorTok{,} \OperatorTok{\#}\BaseNTok{0x7ffffffffff00000}   \CommentTok{; mask the store address}
\NormalTok{ldr x10}\OperatorTok{,}\NormalTok{ log\_start\_addr           }\CommentTok{; 1MB{-}aligned log start}
\NormalTok{subs x9}\OperatorTok{,}\NormalTok{ x9}\OperatorTok{,}\NormalTok{ x10                  }\CommentTok{; if equal, then abort.}
\NormalTok{b}\OperatorTok{.}\NormalTok{e \_abort}
\end{Highlighting}
\end{Shaded}

The log size is statically defined, and it is also aligned to that size.
i.e.~a 1MB log would be aligned to 1MB address. This makes the check equivalent
to a mask and subtract.

The reason for adding the check \emph{after} the store is to further ensure that a
CFI attack would not be able to bypass the check by jumping to the store.
The check would necessarily be run after the store, and therefore aborting the
execution if the log had been modified.

\paragraph{Optimizing log entries:}\label{optimizing-log-entries}

BLAST takes inspiration from profiling literature to place instrumentation in
an optimal fashion. It uses Ball-Larus algorithm {[}\citeproc{ref-balllarus}{17}{]} to selectively
add instrumentation to the edges of a CFG. The instrumentation manipulates the value of a counter,
which at the end of the CFG would be between \texttt{0} and \texttt{N-1}. Where \texttt{N} is the number
of acyclic paths in the CFG. This counter can be used to uniquely identify the
runtime path that was taken by the function.

This results in \texttt{2x} compact representation of paths compared to OAT's bit tracing,
and it places instrumentation at fewer locations {[}\citeproc{ref-blast}{55}{]}.

\paragraph{WPP:}\label{wpp}

BLAST then takes the large log, and compactly represents it using a context-free
grammar called Whole Program Path (WPP). It is an extension of Ball-Larus numbering, to build a single
control flow path through the complete program {[}\citeproc{ref-laruswpp}{36}, \citeproc{ref-blast}{55}{]}.
This takes the log, that can grow upto MBs or even GBs in size, and converts into
a WPP representation that's just a few hundred bytes big.

\subsubsection{Limitations}\label{limitations}

The thread responsible of committing the log to TEE would have to run in parallel
to the program. Single core settings had an average runtime overhead of 175\%
as compared to 67\% of multi-core execution {[}\citeproc{ref-blast}{55}{]}.

Reserving 2 registers may cause compatibility issues, especially with programs
that rely on inline assembly. In which case, BLAST would not compile.

Also, the binary size overhead can be from 64\% upto 167\% with function inlining.
This would not be reasonable in certain applications or scenarios like lightweight embedded devices.

\subsection{CFA+}\label{cfa-1}

\subsubsection{How it works}\label{how-it-works-1}

Similar to BLAST, CFA+ reserves 2 registers, \texttt{x27} and \texttt{x28}, naming them
\texttt{RR} and \texttt{SR} respectively. They are used to encode/decode the return value in
\texttt{x30} or the link register to prevent it from tampering.

There are 2 main components: 1. Software instrumentation. Which can be seen as
a custom implementation of branch/call authentication. 2. BTI.

3 types of code elements are then instrumented {[}\citeproc{ref-cfaplus}{4}{]}:

\begin{itemize}
\tightlist
\item
  \emph{Function Prologues:}
  All functions that are candidates for indirect calls start
  with a \texttt{bti\ c}, followed by a block to verify the legitimacy of the caller.
  That block is followed by a label used for direct calls to that function.\\
  Checking for legitimate callers is done by analysing type propogation and giving
  a mask value to all possible callers. If the mask value is present in \texttt{x15} at
  the time of call, it is legitimate and jump to the direct call label,
  else jump to an invalid address in \texttt{LR} using \texttt{blr\ x30}.
  (\texttt{LR} would have an address to a \texttt{bti\ j} so a call would cause a violation.)
  After the direct call label, the \texttt{LR} is encoded and stored in the stack by using
  \texttt{LR\ =\ LR} \(\oplus\) \texttt{SR}.
\item
  \emph{Function Epilogues:}
  \texttt{LR} is loaded and unmasked by XORing again with \texttt{SR} before returns.
\item
  \emph{Calls:}
  Direct and indirect calls are surrounded by instructions that encode and decode the \texttt{SR}.
  The call instruction is preceeded by instructions to encode \texttt{SR} with a unique ID by XORing it.
  The call is then followed by a \texttt{bti\ j} landing pad, and instructions to decode the \texttt{SR}.
  This helps in checking if the call returned from the same callee.
  If the control returned from somewhere else, it would corrupt the
  \texttt{SR}'s value which would cause the \texttt{LR} to be corrupted in function epilogue.
\end{itemize}

It all looks like this:

\begin{Shaded}
\begin{Highlighting}[]
\FunctionTok{foo:}                    \CommentTok{; non{-}leaf callee}
\NormalTok{  bti c                 }\CommentTok{; landing pad for indirect calls; foo prologue starts}
\NormalTok{  ldr x27}\OperatorTok{,} \OperatorTok{=}\NormalTok{mask        }\CommentTok{; load the mask into RR}
  \BuiltInTok{and}\NormalTok{ x27}\OperatorTok{,}\NormalTok{ x27}\OperatorTok{,}\NormalTok{ x15     }\CommentTok{; bitwise AND between mask and ID (in x15)}
  \BuiltInTok{cmp}\NormalTok{ x27}\OperatorTok{,}\NormalTok{ x15          }\CommentTok{; compare result in x27 with ID}
\NormalTok{  b}\OperatorTok{.}\NormalTok{eq foo\_direct       }\CommentTok{; if equal, resume foo by jumping to foo\_direct}
\NormalTok{  blr x30               }\CommentTok{; else jump to invalid address in LR}
\FunctionTok{foo\_direct:}
\NormalTok{  eor x30}\OperatorTok{,}\NormalTok{ x30}\OperatorTok{,}\NormalTok{ x28     }\CommentTok{; mask LR (x30) using SR (x28)}
  \BuiltInTok{str}\NormalTok{ x30}\OperatorTok{,} \KeywordTok{sp}\OperatorTok{[{-}}\DecValTok{8}\OperatorTok{]!}      \CommentTok{; push LR to stack}
\NormalTok{  ...                   }\CommentTok{; rest of foo prologue}
\NormalTok{  ...}
\NormalTok{  ...                   }\CommentTok{; foo epilogue starts}
\NormalTok{  ldr x30}\OperatorTok{,} \OperatorTok{[}\KeywordTok{sp}\OperatorTok{],} \DecValTok{8}      \CommentTok{; load LR from stack}
\NormalTok{  eor x30}\OperatorTok{,}\NormalTok{ x30}\OperatorTok{,}\NormalTok{ x28     }\CommentTok{; unmask LR using SR}
  \ControlFlowTok{ret}

\FunctionTok{bar:}                    \CommentTok{; non{-}root caller}
\NormalTok{  ...                   }\CommentTok{; bar prologue (similar to foo)}
\NormalTok{  ...}
\NormalTok{  ldr x15}\OperatorTok{,} \OperatorTok{=}\NormalTok{IDx         }\CommentTok{; load ID of indirect call}
\NormalTok{  eor x28}\OperatorTok{,}\NormalTok{ x28}\OperatorTok{,}\NormalTok{ x15     }\CommentTok{; encode SR using ID (in x15)}
\NormalTok{  blr x9                }\CommentTok{; indirect call, may go to foo or baz}
\NormalTok{  bti j                 }\CommentTok{; landing pad for ret}
\NormalTok{  ldr x15}\OperatorTok{,} \OperatorTok{=}\NormalTok{IDx         }\CommentTok{; load ID again}
\NormalTok{  eor x28}\OperatorTok{,}\NormalTok{ x28}\OperatorTok{,}\NormalTok{ x15     }\CommentTok{; decode SR using ID (in x15)}
\NormalTok{  ...}
\NormalTok{  ldr x15}\OperatorTok{,} \OperatorTok{=}\NormalTok{IDy         }\CommentTok{; load ID of direct call}
\NormalTok{  eor x28}\OperatorTok{,}\NormalTok{ x28}\OperatorTok{,}\NormalTok{ x15     }\CommentTok{; encode SR using ID (in x15)}
\NormalTok{  bl foo\_direct         }\CommentTok{; direct call to foo}
\NormalTok{  bti j                 }\CommentTok{; landing pad for ret}
\NormalTok{  ldr x15}\OperatorTok{,} \OperatorTok{=}\NormalTok{IDy         }\CommentTok{; load ID again}
\NormalTok{  eor x28}\OperatorTok{,}\NormalTok{ x28}\OperatorTok{,}\NormalTok{ x15     }\CommentTok{; decode SR using ID (in x15)}
\NormalTok{  ...                   }\CommentTok{; bar epilogue (similar to foo)}
\end{Highlighting}
\end{Shaded}

Calling shared libraries is also handled similar to this using \texttt{RR} instead of \texttt{SR}.
But, just the returns points are checked, and the libraries themselves are not
instrumented or protected. As for the logging, all violations are logged by an
exception handler running in the kernel space. Other details about values needed for
attestation and when they are logged are not discussed in the paper in much detail.

\sethlcolor{pink}\hl{working fig.png cfaplus fig 4}\sethlcolor{correctioncolor}

\subsubsection{Outcome}\label{outcome}

CFA+ reports its overall average runtime overhead to be 1.5\%.
The major factor affecting runtime overhead is the ratio and type of call instructions
compared to total instructions and the call frequency.
Direct calls are optimised by skipping the caller checks, and therefore do not
significantly contribute to runtime overheads. Indirect calls on the other hand
cause the caller and callee checks to be executed, and add to the runtime overhead.
External calls to shared libraries are only instrumented at the call sites, with
no guarantees added to the libraries themselves. So, they have small impact on
the runtime overhead.

\subsubsection{Limitations}\label{limitations-1}

A major flaw in the design is that the IDs that are being checked against are static.
That is, they won't change between executions or even different copies of the same binary.
Attackers would be able to figure out the IDs and required values for \texttt{SR} and \texttt{RR} using
reverse engineering and/or symbolic execution. If \texttt{SR}'s value for a given path
is known, it becomes easy to calculate the needed modifier value to change the
\texttt{LR} in stack so that when it gets ``unmasked'' with \texttt{SR}, it points to a desired address.
This enables the return to be controlled by the attacker. As returns can jump to \texttt{bti\ j},
any such instruction becomes a possible landing pad for it.

Similarly, the protection against indirect calls does little to help. Although
there is a check for the mask value, if an attacker has ability override a register to
hijack a \texttt{br} or \texttt{blr} call, loading the target function's mask in \texttt{x15} would not
add significant difficulty. A call, if hijacked, can then run the whole function
and its subsequent path normally.

Direct call labels (or symbols as called in the paper) for a function added by CFA+,
should be followed by \texttt{bti\ jc} to not cause a hardware exception.
This is because that label is a direct call target as well as a jump target for
the function's check prologue. This is not shown in the various listings as well as the paper text.
If it is there, or if the label acts as a \texttt{bti\ jc}, jumps to these labels can be
arbitrary as there are no checks for legitimate callers following them.

These problems could be solved by using dynamic values for IDs. As for how will that
be implemented remains a question. Another solution would be to use PAC, which
was decided against citing performance drawbacks, and that ``PA relies on confidential
data, such as secrets, which exposes it to a wider range of attack surfaces including
various side channels {[}\citeproc{ref-azad2020ios}{16}, \citeproc{ref-cai2023demystifying}{18}, \citeproc{ref-ravichandran2022pacman}{45}{]}.
In contrast, the current design of CFA+ is transparent, i.e.,
secret-independent, resulting in a smaller attack surface.'' {[}\citeproc{ref-cfaplus}{4} - Section 7{]}.

Logging for attestation is either done on violation, or on demand from the Vrf. And in both cases,
the value of \texttt{SR} \texttt{RR} and \texttt{PC} are recorded. The Vrf performs a satisfiability check,
followed by \texttt{RR} consistency check for the paths, and a \texttt{SR} + \texttt{PC} consistency check.
If there is at-least one valid path found, the program is concluded to be benign.
As the logging is on-demand, an attacker may take control after the readings are taken,
and would be able to keep it until the next request comes from the Vrf.

Code inside shared libraries is not protected, and checked, therefore it's possible to
exploit those to gain control of the program without triggering a violation.

\chapter{Extending BLAST for CFI}\label{extending-blast-for-cfi}

\minitoc 

\emph{Armed} with the background information, we can now take a look at why and how we can improve
upon BLAST to give additional security guarantees, and maybe get a bit of a performance boost
while we are at it.

\section{Why?}\label{why-1}

CFA mechanisms rely on the fact that a malicious actor would not want their attack
to be detected. And for this there attack must not leave any trace in the log that
would be visible to the verifier. But what if the attacker does not care about if
their attack is visible or not, if the damage is done? Code reuse attacks become
very easy in this case, as most CFA techniques aim to detect them, but not prevent them.

Taking the example of the syringe pump, if an attacker has used ROP gadgets to
change the control flow of the pump to inject 10 ml instead of 1 ml, it doesn't
matter if we can detect if afterwards as the person's safety has already been compromised.

Our goal in this case is to prevent these kinds of scenarios.

People have been working on CFI and CFA parallelly as two solutions to similar
problems, but they have not thought about applying both of these together {[}\citeproc{ref-cfaplus}{4}, \citeproc{ref-sok}{5}{]}.
When applied together, these techniques sometimes complement each other and cover
each other's disadvantages. For example, adding integrity to some parts of the
code would remove the need for logging those parts, decreasing the runtime overhead
due to attestation, which is a common problem in the CFA literature {[}\citeproc{ref-sok}{5}{]}.

\sethlcolor{pink}\hl{CFA+ is there, but the limitations are listed, we need better solution.}\sethlcolor{correctioncolor}

\sethlcolor{pink}\hl{Also write about the constant monitor for input idea. BLAST is experiment in that direction}\sethlcolor{correctioncolor}

Before going forward, we should list out some of our assumptions:

\begin{itemize}
\tightlist
\item
  Write XOR Execute (\texttt{W} \(\oplus\) \texttt{X}) is enabled on pages. Code injection/modification in not possible.
\item
  Hardware is implicitly trusted.
\item
  Communication between Vrf and Prv is secure.
\item
  OS is not trusted if and only if page management and interrupt handling is mediated
  by the secure monitor.
\item
  Libraries are instrumented and statically linked to the binary.
\end{itemize}

\section{How to add Integrity guarantees?}\label{adding-integrity}

As discussed in \hyperref[cfi]{1.1.1 - CFI}, when talking about code reuse attacks, they can be further divided into
Control flow hijacking (control data) and Data only (non-control data) attacks.
We will talk about preventing control flow hijacking attacks first.
The two main categories of control flow hijacking attacks are: ROP and JOP.
We have talked about them in ARM Specifics \hyperref[pac-bg]{1.2.2 - PAC} and \hyperref[bti-bg]{1.2.3 - BTI} respectively.

Adding BTI to a binary would prevent JOP attacks disabling an attacker from changing
the control flow of the program and corrupting the forward edges of the CFG.
Use of \texttt{BR}, \texttt{BLR} and similar instructions to pivot to arbitrary code would generate hardware
level exceptions, which could then be logged and handled appropriately.

Similarly, adding PAC to a binary would prevent ROP attacks, disabling corruption
of backward egdes of the CFG.
Use of \texttt{RET} instructions to chain gadgets to run arbitrary code would become hard
as all returns would be preceded by an address check. Failing which would generate
a hardware level exception.

\sethlcolor{pink}\hl{cfa would detect \ldots{}\\
As for data only attacks, CFA part would handle it. how? repeat this ans in \#qual eval}\sethlcolor{correctioncolor}

We can also optionally enable Memory Tagging Extension (MTE), or memory coloring,
an Armv8.5-A extension {[}\citeproc{ref-arm-pacbti}{9}{]}. It enables detection of memory safety violations like use after free
and buffer overflows by assigning tags to memory regions. Any data access would
require a tag check in the address. Checking and Violations can be handled both
synchronously and asynchronously depending on performance needs.
As the tags, like PAC, use upper bits of the address, PAC would have fewer bits available.

But, MTE support for processors and Kernel is in early stage and is actively being worked upon {[}\citeproc{ref-mte-kern-patch}{56}{]}.
Therefore, we will skip this feature for now and it can be used in the future when platforms
have better support for it.

We have some more instructions provided by the PAC and BTI feature flags,
like \texttt{BLRAA} - Authenticate and branch, or \texttt{RETAA} - Authenticate and return.
But they are not in the NOP-space. So for the sake of backwards compatibility,
we choose to not use them for now.

\subsubsection{But, do PAC and BTI help in limiting the number of gadgets?}\label{but-do-pac-and-bti-help-in-limiting-the-number-of-gadgets}

According to ARM's testing, when these features were enabled for GLIBC, the number
of available gadgets was reduced by 97.65\%. This can be seen in figure \ref{fig:pac-bti-gadgets}.
Similar results were also seen for CFA+ {[}\citeproc{ref-cfaplus}{4}{]}.

\begin{figure}

{\centering \includegraphics[width=1\linewidth]{./imgs/placeholder-pac-bti-gadgets} 

}

\caption{ROP and JOP gadgets in GLIBC}\label{fig:pac-bti-gadgets}
\end{figure}

\subsubsection{What about the binary size overhead then?}\label{what-about-the-binary-size-overhead-then}

Binary size overhead for these, when checked for GLIBC by ARM, was 2.9\% for both
when considering backwards compatibility. If compiled for Armv8.3-A and later,
it drops to 1.61\% {[}\citeproc{ref-arm-pacbti}{9}{]}.
This overhead is less significant when compared to BLAST instrumentation, which
came to 64\% without inlining {[}\citeproc{ref-blast}{55}{]}.

\sethlcolor{pink}\hl{We will discuss this further in \#eval after we implement extended BLAST.}\sethlcolor{correctioncolor}

\subsubsection{What is our target compatibility?}\label{what-is-our-target-compatibility}

As mentioned previously, PAC and BTI can be backwards compatible with ARMv8-A processors
that do not support them, but will just be treated as \texttt{NOP} instructions.
The same binary would run on ARMv8.5-A processors with PAC + BTI guarantees, and
ARMv8.3-A with BTI turned off.
We also should keep in mind that PAC support is only enabled if the linked libraries
are also PAC enabled.
Compatibility is discussed in further detail in section \hyperref[compatibility]{3.2 Compatibility}.

\section{PAC + BTI gives us room to optimize BLAST}\label{optimizing-blast}

Now that we have checks on branches and calls, we do not need to log each loop's iteration.
Loop labels are protected by \texttt{BTI\ j} landing pads. They cannot be jumped to arbitrarily.
And as for the jumps: \texttt{B}, \texttt{B.cond}, \texttt{BL} have labels, and are direct branches protected
against code modification.
While \texttt{BR} and \texttt{BLR} use registers, and would not be used for loop control,
they still cannot jump arbitrarily as they would be preceded by pointer authentication.
Similarly, funtion returns aren't required to target landing pads, and may target loop labels,
but due to PAC, all returns would be authenticated first.

Due to this, we can skip logging each loop iteration which would result in less
log entries, and subsequently less number of domain switches. The amount of logging
decreased can be seen in \ref{tab:logevent-totals}.
The performance benifits are discussed in \hyperref[performance]{3.3 Performance}.

\section{Log Levels for control over report granularity}\label{log-levels-for-control-over-report-granularity}

Now, what if we need fine-grained CFlog reports with each log iteration, etc?
Or what if we need more performance out of extended BLAST at the cost of CFlog granularity?

We can add log levels to BLAST then. These are:

\begin{itemize}
\tightlist
\item
  \emph{Violation}: Coarse-grained. Only PAC/BTI faults are logged and handled.
\item
  \emph{Inter-procedure}: Extended BLAST. Loop events aren't logged.
\item
  \emph{Intra-procedure}: Fine-grained. Original BLAST. Loop events are logged at cost of performance.
\end{itemize}

One thing to note here is that, BLAST instrumentation is added statically to the binary.
This means the log levels are set at compile time, and cannot be changed at runtime.

\chapter{Evaluation}\label{evaluation}

\minitoc 

\section{Qualitative Security Analysis}\label{qualitative-security-analysis}

For our case, an attacker either controls the Prv or is a malicious Prv that changes
the control flow of the program, while trying to keep the CFlog intact
or succeeds in completing malicious operations before Vrf gets the report.
A weaker set of these guarantees provided by BLAST, target an attacker that changes the control flow,
but cares about not being detected.
As described in sections \hyperref[adding-integrity]{2.2 - Adding Integrity} and
\hyperref[optimizing-blast]{2.3 - Optimizing Blast}, we add on top this weaker set of guarantees,
to provide the integrity guarantees.

Code corruption attacks that would replace the code can be prevented
as the function calls and returns would generate exceptions without properly signed
addresses. And even still, attacks would be detected as the call/return addresses and
the path numbers collected in the CFlog would not match. For code injection attacks,
we assume that Prv has data-execution prevention implemented in the REE.
For ensuring the integrity of the CFlog, all memory stores from code already inside the
program are followed by SFI instrumentation.

As for the possibility of code-reuse attacks, the target surface for any jumps is
decreased just to \texttt{bti} instructions, while the jumps (and returns) themselves are
protected by pointer authentication. The increase in binary sizes from enabling BTI is \textasciitilde2\% {[}\citeproc{ref-arm-pacbti}{9}{]},
that means the jump target surface for code-reuse attacks decreases to that amount.
Attacker would need to target those gadgets, while also considering
pointer authentication. Any successfull attacks bypassing these measures, would
be detected in the CFlog due to BLAST instrumentation. To prevent detection,
attacker would also need to find gadgets in the reduced subset to modify \texttt{BLReg} and \texttt{LogReg}.
BLAST already provides guarantees against bypassing detection {[}\citeproc{ref-blast}{55}{]}.

Attacks to program data to alter the control flow of a program is detected in the CFlog.
But, it would still be possible to alter the sensitive variables in a way that
does not affect the control flow. These attacks are not in our scope or the threat model.
However, this can be addressed by adding instrumentation that also logs the values
of sensitive variables alongside the CFlog {[}\citeproc{ref-sun2020oat}{52}{]}.

Reliable, Continuous or On-demand delivery of CFreport is orthogonal to this work, but can
be added on top to provide additional guarantees. TA can be configured to send
continuous reports, so that Vrf can detect attacks early on and take action accordingly.
Also, the CFI exception handlers can be configured to report violations, and take
measures to abort execution or perform recovery. This is especially useful
in applications where active attacks are absent, but we need similar guarantees on
execution of the operations. For example, a rover, satellite or a robotic arm controller.

\section{Compatibility}\label{compatibility}

Although the measures described so far are ARM specific, the concepts themselves
are portable to other platforms and targets.
For example, if PAC is replaced with something else, which provides similar
guarantees, our techniques would still work. Case in point, Intel has Indirect
Branch Tracking (IBT) for x86-64 which gives instructions that act as branch targets {[}\citeproc{ref-intel-ibt}{32}{]}.

As for the compatibility of the prototype, if compiled with \texttt{-march=armv8a}, it
provides a binary that's backwards compatible with ARMv8-A processors,
but does not provide the integrity guarantees.
The integrity additions are only fully supported on ARMv8.5-A and later microarchitectures.
So, the prototype is fully compatible with those, while providing only attestation for
backwards compatible platforms.

This work, as with BLAST, can be applied to other CFA approaches to provide
integrity and/or performance. Similarly, Data Flow Integrity and Data Flow Attestation
techniques are complementary to this.

\section{Performance}\label{performance}

\begin{table}
\centering
\caption{\label{tab:logevents}Number of logging events}
\centering
\resizebox{\ifdim\width>\linewidth\linewidth\else\width\fi}{!}{
\begin{threeparttable}
\begin{tabular}[t]{lrrrrr}
\toprule
\multicolumn{1}{c}{\makecell[l]{Embench IoT\\Program}} & \multicolumn{1}{c}{\makecell[l]{Conditional\\Branches}} & \multicolumn{1}{c}{\makecell[l]{Unconditional\\Branches}} & \multicolumn{1}{c}{\makecell[l]{Loop\\Headers}} & \multicolumn{1}{c}{\makecell[l]{Function\\Calls}} & \multicolumn{1}{c}{Returns/Exits}\\
\midrule
aha-mont64 & 384,507,002 & 456,417,002 & 189,927,000 & 8,460,006 & 8,460,006\\
crc32 & 174,420,002 & 348,670,002 & 174,250,000 & 174,420,006 & 174,420,006\\
cubic & 660,007 & 970,003 & 310,000 & 200,006 & 200,006\\
edn & 371,925,005 & 732,801,003 & 360,876,000 & 696,006 & 696,006\\
huffbench & 495,825,002 & 486,255,002 & 233,266,000 & 1,078,006 & 1,078,006\\
\addlinespace
malmult-int & 406,732,884 & 794,099,724 & 387,366,840 & 92,807 & 92,807\\
minver & 109,335,036 & 155,955,031 & 56,610,012 & 6,105,006 & 6,105,006\\
nbody & 6,228,064 & 10,849,050 & 4,621,020 & 101,006 & 101,006\\
nettle-aes & 78,000,771 & 147,732,515 & 51,168,256 & 858,006 & 858,006\\
nettle-sha256 & 30,400,019 & 185,250,019 & 24,225,008 & 3,800,006 & 3,800,006\\
\addlinespace
primecount & 880,205,002 & 726,973,002 & 282,281,000 & 1,006 & 1,006\\
sglib-combined & 680,950,108 & 627,474,208 & 144,884,400 & 76,618,308 & 76,618,308\\
st & 9,204,004 & 18,317,003 & 9,113,000 & 7,904,006 & 7,904,006\\
tarfind & 80,905,424 & 114,040,424 & 48,400,474 & 36,331,006 & 36,331,006\\
ud & 412,362,003 & 616,326,003 & 255,694,000 & 1,478,006 & 1,478,006\\
\bottomrule
\end{tabular}
\begin{tablenotes}[para]
\item \textit{Note.} 
\item The number of events is taken with CPU\_MHZ=1000, a parameter denoting the number of runs of each top-level benchmark function.
\end{tablenotes}
\end{threeparttable}}
\end{table}

\begin{table}
\centering
\caption{\label{tab:logevent-totals}Total events}
\centering
\resizebox{\ifdim\width>\linewidth\linewidth\else\width\fi}{!}{
\begin{threeparttable}
\begin{tabular}[t]{lrrrr}
\toprule
\multicolumn{1}{c}{\makecell[l]{Embench IoT\\Program}} & \multicolumn{1}{c}{CFLAT} & \multicolumn{1}{c}{OAT} & \multicolumn{1}{c}{BLAST} & \multicolumn{1}{c}{\makecell[l]{BLAST\\Inter-Procedure}}\\
\midrule
aha-mont64 & 857,844,016 & 392,967,008 & 206,847,012 & 16,920,012\\
crc32 & 871,930,016 & 348,840,008 & 523,090,012 & 348,840,012\\
cubic & 2,030,022 & 860,013 & 710,012 & 400,012\\
edn & 1,106,118,020 & 372,621,011 & 362,268,012 & 1,392,012\\
huffbench & 984,236,016 & 496,903,008 & 235,422,012 & 2,156,012\\
\addlinespace
malmult-int & 1,201,018,222 & 406,825,691 & 387,552,454 & 185,614\\
minver & 277,500,079 & 115,440,042 & 68,820,024 & 12,210,012\\
nbody & 17,279,126 & 6,329,070 & 4,823,032 & 202,012\\
nettle-aes & 227,449,298 & 78,858,777 & 52,884,268 & 1,716,012\\
nettle-sha256 & 223,250,050 & 34,200,025 & 31,825,020 & 7,600,012\\
\addlinespace
primecount & 1,607,180,016 & 880,206,008 & 282,283,012 & 2,012\\
sglib-combined & 1,461,660,932 & 757,568,416 & 298,121,016 & 153,236,616\\
st & 43,329,019 & 17,108,010 & 24,921,012 & 15,808,012\\
tarfind & 267,607,860 & 117,236,430 & 121,062,486 & 72,662,012\\
ud & 1,031,644,018 & 413,840,009 & 258,650,012 & 2,956,012\\
\bottomrule
\end{tabular}
\begin{tablenotes}[para]
\item \textit{Note.} 
\item Inter-Procedure log level has median difference of 91.82\% with 46.13\% being 25\% lows.
\end{tablenotes}
\end{threeparttable}}
\end{table}

\begin{landscape}\begin{table}
\centering
\caption{\label{tab:cleandata}Overheads}
\centering
\resizebox{\ifdim\width>\linewidth\linewidth\else\width\fi}{!}{
\begin{threeparttable}
\begin{tabular}[t]{llrrrrrrrrrr}
\toprule
\multicolumn{1}{c}{ } & \multicolumn{5}{c}{Median Runtime} & \multicolumn{4}{c}{Overhead (\%) over Baseline} & \multicolumn{2}{c}{Overhead (\%) over BLAST} \\
\cmidrule(l{3pt}r{3pt}){2-6} \cmidrule(l{3pt}r{3pt}){7-10} \cmidrule(l{3pt}r{3pt}){11-12}
\multicolumn{1}{c}{ } & \multicolumn{2}{c}{Baseline} & \multicolumn{3}{c}{Blast} & \multicolumn{1}{c}{Baseline} & \multicolumn{3}{c}{Blast} & \multicolumn{2}{c}{Blast} \\
\cmidrule(l{3pt}r{3pt}){2-3} \cmidrule(l{3pt}r{3pt}){4-6} \cmidrule(l{3pt}r{3pt}){7-7} \cmidrule(l{3pt}r{3pt}){8-10} \cmidrule(l{3pt}r{3pt}){11-12}
\multicolumn{1}{c}{Program} & \multicolumn{1}{c}{ } & \multicolumn{1}{c}{PACBTI} & \multicolumn{1}{c}{ } & \multicolumn{1}{c}{PACBTI} & \multicolumn{1}{c}{PACBTI (Inter)} & \multicolumn{1}{c}{PACBTI} & \multicolumn{1}{c}{ } & \multicolumn{1}{c}{PACBTI} & \multicolumn{1}{c}{PACBTI (Inter)} & \multicolumn{1}{c}{PACBTI} & \multicolumn{1}{c}{PACBTI (Inter)}\\
\midrule
aha\_mont64 & 3.630 & 3.946 & 33.812 & 33.814 & 13.342 & 8.709 & 831.437 & 831.471 & 267.538 & ** & -60.541\\
crc32 & 3.774 & 3.799 & 150.781 & 150.677 & 125.394 & 0.651 & 3895.192 & 3892.437 & 3222.528 & -0.069 & -16.837\\
cubic & 2.377 & 2.477 & 2.931 & 3.264 & 3.234 & 4.216 & 23.301 & 37.315 & 36.075 & 11.366 & 10.360\\
edn & 7.410 & 7.568 & 52.801 & 52.777 & 16.807 & 2.130 & 612.545 & 612.224 & 126.807 & ** & -68.169\\
huffbench & 3.888 & 3.823 & 34.731 & 34.739 & 9.950 & -1.686 & 793.185 & 793.395 & 155.876 & ** & -71.352\\
\addlinespace
matmult\_int & 4.853 & 4.863 & 56.139 & 56.127 & 12.506 & ** & 1056.769 & 1056.517 & 157.695 & ** & -77.723\\
minver & 1.903 & 2.013 & 12.985 & 12.985 & 6.677 & 5.805 & 582.504 & 582.472 & 250.928 & ** & -48.582\\
nbody & 0.256 & 0.277 & 1.219 & 1.221 & 0.886 & 8.319 & 376.497 & 377.328 & 246.537 & 0.174 & -27.274\\
nettle\_aes & 4.127 & 4.296 & 9.707 & 9.949 & 9.077 & 4.092 & 135.198 & 141.041 & 119.917 & 2.485 & -6.497\\
nettle\_sha256 & 4.325 & 4.819 & 10.063 & 10.760 & 10.373 & 11.425 & 132.699 & 148.802 & 139.860 & 6.920 & 3.077\\
\addlinespace
primecount & 5.691 & 5.690 & 40.994 & 40.996 & 8.874 & ** & 620.296 & 620.337 & 55.922 & ** & -78.353\\
sglib\_combined & 7.322 & 13.289 & 76.378 & 76.327 & 55.432 & 81.498 & 943.186 & 942.487 & 657.095 & -0.067 & -27.425\\
st & 0.374 & 0.381 & 7.439 & 7.441 & 6.123 & 1.817 & 1887.114 & 1887.570 & 1535.575 & ** & -17.691\\
tarfind & 1.489 & 1.486 & 33.495 & 33.486 & 26.506 & ** & 2149.221 & 2148.673 & 1679.901 & ** & -20.866\\
ud & 5.791 & 5.791 & 38.252 & 38.230 & 13.917 & ** & 560.508 & 560.123 & 140.305 & -0.058 & -63.618\\
\bottomrule
\end{tabular}
\begin{tablenotes}[para]
\item \textit{Note.} 
\item Samples n=100 for each program, along with CPU\_MHZ=1000. (**) values are omitted as the overhead was not significant according to Wilcoxon Signed Ranked Test.
\end{tablenotes}
\end{threeparttable}}
\end{table}
\end{landscape}

\subsection{Benchmark Environment}\label{benchmark-environment}

\subsection{Theoretical Boost}\label{theoretical-boost}

\subsection{Numbers}\label{numbers}

\chapter{Discussion}\label{discussion}

\minitoc 

\section{Limitations}\label{limitations-2}

\sethlcolor{pink}\hl{Edit/Add to this part}\sethlcolor{correctioncolor}

Although not a limitation in this work, our aim was to add checks in the TEE
that would monitor the program execution and if integrity has been violated,
abort the execution. We can pursue this further by modifying CFLAT/OAT monitor.

The benchmarks do not include whole program path generation part.

The logging on violation part, although mentioned has not been implemented yet
in the prototype. This can also be implementation dependent and users may choose
to abort execution instead of logging.

Some of the assumptions like \texttt{W} \(\oplus\) \texttt{X} are not foolproof and there are
proof of concepts exploiting them. We need to decrease the TCB and the
assumptions to increase the security guarantees given by this work.

Could not add other CFI measures than PAC and BTI.

PAC is only enabled if the whole dependency chain also has it enabled so we
cannot use PAC with pre-compiled binaries that do not have it enabled.

The benchmarking was done on a simulated Raspberry pi inside qemu instead of a
hardware board. Thus we have only taken the ratio of baseline code and the
instrumented code. The timings may differ a bit on a physical board.

\section{Why is it better than CFA+}\label{why-is-it-better-than-cfa}

\section{Future Research}\label{future-research}

\chapter*{Conclusion}\label{conclusion}
\addcontentsline{toc}{chapter}{Conclusion}

\startappendices

\chapter{The First Appendix}\label{the-first-appendix}

This first appendix includes an R chunk that was hidden in the document (using \texttt{echo\ =\ FALSE}) to help with readibility:

\textbf{In 02-rmd-basics-code.Rmd}

\textbf{And here's another one from the same chapter, i.e.~Chapter \ref{code}:}

\chapter{The Second Appendix, for Fun}\label{the-second-appendix-for-fun}

\chapter*{References}\label{references}
\addcontentsline{toc}{chapter}{References}

\markboth{References}{}

\phantomsection\label{refs}
\begin{CSLReferences}{0}{0}
\bibitem[\citeproctext]{ref-abadi2009control}
\CSLLeftMargin{{[}1{]} }%
\CSLRightInline{Martn Abadi, Mihai Budiu, Ulfar Erlingsson, and Jay Ligatti. 2009. Control-flow integrity principles, implementations, and applications. \emph{ACM Transactions on Information and System Security (TISSEC)} 13, 1 (2009), 1--40.}

\bibitem[\citeproctext]{ref-abera2016cflat}
\CSLLeftMargin{{[}2{]} }%
\CSLRightInline{Tigist Abera, N Asokan, Lucas Davi, Jan-Erik Ekberg, Thomas Nyman, Andrew Paverd, Ahmad-Reza Sadeghi, and Gene Tsudik. 2016. C-FLAT: Control-flow attestation for embedded systems software. In \emph{Proceedings of the 2016 ACM SIGSAC conference on computer and communications security}, 2016. 743--754.}

\bibitem[\citeproctext]{ref-abera2019diat}
\CSLLeftMargin{{[}3{]} }%
\CSLRightInline{Tigist Abera, Raad Bahmani, Ferdinand Brasser, Ahmad Ibrahim, Ahmad-Reza Sadeghi, and Matthias Schunter. 2019. DIAT: Data integrity attestation for resilient collaboration of autonomous systems. In \emph{NDSS}, 2019.}

\bibitem[\citeproctext]{ref-cfaplus}
\CSLLeftMargin{{[}4{]} }%
\CSLRightInline{Mahmoud Ammar, Ahmed Abdelraoof, and Silviu Vlasceanu. 2024. On bridging the gap between control flow integrity and attestation schemes. In \emph{33rd USENIX security symposium (USENIX security 24)}, 2024. 6633--6650.}

\bibitem[\citeproctext]{ref-sok}
\CSLLeftMargin{{[}5{]} }%
\CSLRightInline{Mahmoud Ammar, Adam Caulfield, and Ivan De Oliveira Nunes. 2024. Sok: Integrity, attestation, and auditing of program execution. In \emph{2025 IEEE symposium on security and privacy (SP)}, 2024. IEEE Computer Society, 77--77.}

\bibitem[\citeproctext]{ref-arbaugh1997secure}
\CSLLeftMargin{{[}6{]} }%
\CSLRightInline{William A Arbaugh, David J Farber, and Jonathan M Smith. 1997. A secure and reliable bootstrap architecture. In \emph{Proceedings. 1997 IEEE symposium on security and privacy (cat. No. 97CB36097)}, 1997. IEEE, 65--71.}

\bibitem[\citeproctext]{ref-armtz}
\CSLLeftMargin{{[}7{]} }%
\CSLRightInline{Arm. 2020. TrustZone for Armv8-a. Retrieved from \url{https://developer.arm.com/-/media/Arm\%20Developer\%20Community/PDF/Learn\%20the\%20Architecture/TrustZone\%20for\%20Armv8-A.pdf?revision=c3134c8e-f1d0-42ff-869e-0e6a6bab824f}}

\bibitem[\citeproctext]{ref-armasm-user-guide}
\CSLLeftMargin{{[}8{]} }%
\CSLRightInline{Arm. 2023. Arm compiler armasm user guide v6.6.5. Retrieved from \url{https://developer.arm.com/documentation/dui0801/l}}

\bibitem[\citeproctext]{ref-arm-pacbti}
\CSLLeftMargin{{[}9{]} }%
\CSLRightInline{Arm. 2023. Learn the architecture - providing protection for complex software v2.0. Retrieved from \url{https://developer.arm.com/documentation/102433/0200}}

\bibitem[\citeproctext]{ref-arm-isa}
\CSLLeftMargin{{[}10{]} }%
\CSLRightInline{Arm. 2024. Learn the architecture - A64 instruction set architecture guide v1.2. Retrieved from \url{https://developer.arm.com/documentation/102374/0102}}

\bibitem[\citeproctext]{ref-arm-arch-manual}
\CSLLeftMargin{{[}11{]} }%
\CSLRightInline{Arm. 2024. Arm architecture reference manual for a-profile architecture vL.a. Retrieved from \url{https://developer.arm.com/documentation/ddi0487/la/}}

\bibitem[\citeproctext]{ref-arm-pcs}
\CSLLeftMargin{{[}12{]} }%
\CSLRightInline{Arm. 2025. Procedure call standard for the arm 64-bit architecture. Retrieved from \url{https://github.com/ARM-software/abi-aa/blob/main/aapcs64/aapcs64.rst}}

\bibitem[\citeproctext]{ref-arm-feat-names}
\CSLLeftMargin{{[}13{]} }%
\CSLRightInline{Arm. 2025. Feature names in a-profile architecture v2025\_03. Retrieved from \url{https://developer.arm.com/documentation/109697/2025_03}}

\bibitem[\citeproctext]{ref-asokan2015seda}
\CSLLeftMargin{{[}14{]} }%
\CSLRightInline{Nadarajah Asokan, Ferdinand Brasser, Ahmad Ibrahim, Ahmad-Reza Sadeghi, Matthias Schunter, Gene Tsudik, and Christian Wachsmann. 2015. Seda: Scalable embedded device attestation. In \emph{Proceedings of the 22nd ACM SIGSAC conference on computer and communications security}, 2015. 964--975.}

\bibitem[\citeproctext]{ref-aeg2014}
\CSLLeftMargin{{[}15{]} }%
\CSLRightInline{Thanassis Avgerinos, Sang Kil Cha, Alexandre Rebert, Edward J Schwartz, Maverick Woo, and David Brumley. 2014. Automatic exploit generation. \emph{Communications of the ACM} 57, 2 (2014), 74--84.}

\bibitem[\citeproctext]{ref-azad2020ios}
\CSLLeftMargin{{[}16{]} }%
\CSLRightInline{Brandon Azad. 2020. iOS kernel PAC, one year later. Retrieved from \url{https://bazad.github.io/presentations/BlackHat-USA-2020-iOS_Kernel_PAC_One_Year_Later.pdf}}

\bibitem[\citeproctext]{ref-balllarus}
\CSLLeftMargin{{[}17{]} }%
\CSLRightInline{Thomas Ball and James R Larus. 1996. Efficient path profiling. In \emph{Proceedings of the 29th annual IEEE/ACM international symposium on microarchitecture. MICRO 29}, 1996. IEEE, 46--57.}

\bibitem[\citeproctext]{ref-cai2023demystifying}
\CSLLeftMargin{{[}18{]} }%
\CSLRightInline{Zechao Cai, Jiaxun Zhu, Wenbo Shen, Yutian Yang, Rui Chang, Yu Wang, Jinku Li, and Kui Ren. 2023. Demystifying pointer authentication on apple m1. In \emph{32nd USENIX security symposium (USENIX security 23)}, 2023. 2833--2848.}

\bibitem[\citeproctext]{ref-caulfield2024traces}
\CSLLeftMargin{{[}19{]} }%
\CSLRightInline{Adam Caulfield, Antonio Joia Neto, Norrathep Rattanavipanon, and Ivan De Oliveira Nunes. 2024. Traces: Tee-based runtime auditing for commodity embedded systems. \emph{arXiv preprint arXiv:2409.19125} (2024).}

\bibitem[\citeproctext]{ref-caulfield2023acfa}
\CSLLeftMargin{{[}20{]} }%
\CSLRightInline{Adam Caulfield, Norrathep Rattanavipanon, and Ivan De Oliveira Nunes. 2023. \(\{\)ACFA\(\}\): Secure runtime auditing \& guaranteed device healing via active control flow attestation. In \emph{32nd USENIX security symposium (USENIX security 23)}, 2023. 5827--5844.}

\bibitem[\citeproctext]{ref-chen2006protocol}
\CSLLeftMargin{{[}21{]} }%
\CSLRightInline{Liqun Chen, Rainer Landfermann, Hans Lhr, Markus Rohe, Ahmad-Reza Sadeghi, and Christian Stble. 2006. A protocol for property-based attestation. In \emph{Proceedings of the first ACM workshop on scalable trusted computing}, 2006. 7--16.}

\bibitem[\citeproctext]{ref-chen2008property}
\CSLLeftMargin{{[}22{]} }%
\CSLRightInline{Liqun Chen, Hans Lhr, Mark Manulis, and Ahmad-Reza Sadeghi. 2008. Property-based attestation without a trusted third party. In \emph{Information security: 11th international conference, ISC 2008, taipei, taiwan, september 15-18, 2008. Proceedings 11}, 2008. Springer, 31--46.}

\bibitem[\citeproctext]{ref-riscyrop}
\CSLLeftMargin{{[}23{]} }%
\CSLRightInline{Tobias Cloosters, David Paaen, Jianqiang Wang, Oussama Draissi, Patrick Jauernig, Emmanuel Stapf, Lucas Davi, and Ahmad-Reza Sadeghi. 2022. Riscyrop: Automated return-oriented programming attacks on risc-v and arm64. In \emph{Proceedings of the 25th international symposium on research in attacks, intrusions and defenses}, 2022. 30--42.}

\bibitem[\citeproctext]{ref-de2021toctou}
\CSLLeftMargin{{[}24{]} }%
\CSLRightInline{Ivan De Oliveira Nunes, Sashidhar Jakkamsetti, Norrathep Rattanavipanon, and Gene Tsudik. 2021. On the TOCTOU problem in remote attestation. In \emph{Proceedings of the 2021 ACM SIGSAC conference on computer and communications security}, 2021. 2921--2936.}

\bibitem[\citeproctext]{ref-dessouky2018litehax}
\CSLLeftMargin{{[}25{]} }%
\CSLRightInline{Ghada Dessouky, Tigist Abera, Ahmad Ibrahim, and Ahmad-Reza Sadeghi. 2018. Litehax: Lightweight hardware-assisted attestation of program execution. In \emph{2018 IEEE/ACM international conference on computer-aided design (ICCAD)}, 2018. IEEE, 1--8.}

\bibitem[\citeproctext]{ref-fraser2004copilot}
\CSLLeftMargin{{[}26{]} }%
\CSLRightInline{T Fraser, J Molina, and W Arbaugh. 2004. Copilot--a coprocessor-based kernel runtime integrity monitor. In \emph{Prof. Int. Conf. USENIX security symp., san diego, CA, USA}, 2004. 13--33.}

\bibitem[\citeproctext]{ref-gasser1989digital}
\CSLLeftMargin{{[}27{]} }%
\CSLRightInline{Morrie Gasser, Andy Goldstein, Charlie Kaufman, and Butler Lampson. 1989. The digital distributed system security architecture. In \emph{Proceedings of the 12th national computer security conference}, 1989. 305--319.}

\bibitem[\citeproctext]{ref-godefroid2012sage}
\CSLLeftMargin{{[}28{]} }%
\CSLRightInline{Patrice Godefroid, Michael Y Levin, and David Molnar. 2012. SAGE: Whitebox fuzzing for security testing. \emph{Communications of the ACM} 55, 3 (2012), 40--44.}

\bibitem[\citeproctext]{ref-hu2019probability}
\CSLLeftMargin{{[}29{]} }%
\CSLRightInline{Jianxing Hu, Dongdong Huo, Meilin Wang, Yazhe Wang, Yan Zhang, and Yu Li. 2019. A probability prediction based mutable control-flow attestation scheme on embedded platforms. In \emph{2019 18th IEEE international conference on trust, security and privacy in computing and communications/13th IEEE international conference on big data science and engineering (TrustCom/BigDataSE)}, 2019. IEEE, 530--537.}

\bibitem[\citeproctext]{ref-huo2020lape}
\CSLLeftMargin{{[}30{]} }%
\CSLRightInline{Dongdong Huo, Yu Wang, Chao Liu, Mingxuan Li, Yazhe Wang, and Zhen Xu. 2020. LAPE: A lightweight attestation of program execution scheme for bare-metal systems. In \emph{2020 IEEE 22nd international conference on high performance computing and communications; IEEE 18th international conference on smart city; IEEE 6th international conference on data science and systems (HPCC/SmartCity/DSS)}, 2020. IEEE, 78--86.}

\bibitem[\citeproctext]{ref-apple-oss}
\CSLLeftMargin{{[}31{]} }%
\CSLRightInline{Apple Inc. 2025. XNU source - apple OSS distributions. Retrieved from \url{https://github.com/apple-oss-distributions/xnu}}

\bibitem[\citeproctext]{ref-intel-ibt}
\CSLLeftMargin{{[}32{]} }%
\CSLRightInline{Intel. 2023. 12th generation intel core processors datasheet. Retrieved from \url{https://edc.intel.com/content/www/us/en/design/ipla/software-development-platforms/client/platforms/alder-lake-desktop/12th-generation-intel-core-processors-datasheet-volume-1-of-2/010/indirect-branch-tracking/}}

\bibitem[\citeproctext]{ref-intel-sgx}
\CSLLeftMargin{{[}33{]} }%
\CSLRightInline{Intel. 2025. Intel SGX for linux. Retrieved from \url{https://github.com/intel/linux-sgx}}

\bibitem[\citeproctext]{ref-kern1999formal}
\CSLLeftMargin{{[}34{]} }%
\CSLRightInline{Christoph Kern and Mark R Greenstreet. 1999. Formal verification in hardware design: A survey. \emph{ACM Transactions on Design Automation of Electronic Systems (TODAES)} 4, 2 (1999), 123--193.}

\bibitem[\citeproctext]{ref-kil2009remote}
\CSLLeftMargin{{[}35{]} }%
\CSLRightInline{Chongkyung Kil, Emre C Sezer, Ahmed M Azab, Peng Ning, and Xiaolan Zhang. 2009. Remote attestation to dynamic system properties: Towards providing complete system integrity evidence. In \emph{2009 IEEE/IFIP international conference on dependable systems \& networks}, 2009. IEEE, 115--124.}

\bibitem[\citeproctext]{ref-laruswpp}
\CSLLeftMargin{{[}36{]} }%
\CSLRightInline{James R Larus. 1999. Whole program paths. \emph{ACM SIGPLAN Notices} 34, 5 (1999), 259--269.}

\bibitem[\citeproctext]{ref-li2011viper}
\CSLLeftMargin{{[}37{]} }%
\CSLRightInline{Yanlin Li, Jonathan M McCune, and Adrian Perrig. 2011. VIPER: Verifying the integrity of PERipherals' firmware. In \emph{Proceedings of the 18th ACM conference on computer and communications security}, 2011. 3--16.}

\bibitem[\citeproctext]{ref-optee}
\CSLLeftMargin{{[}38{]} }%
\CSLRightInline{Linaro Limited. 2025. OPTEE - TrustedFirmware. Retrieved from \url{https://www.trustedfirmware.org/projects/op-tee/}}

\bibitem[\citeproctext]{ref-luk2005dynamic}
\CSLLeftMargin{{[}39{]} }%
\CSLRightInline{Chi-Keung Luk, Robert Cohn, Robert Muth, Harish Patil, Artur Klauser, Geoff Lowney, Steven Wallace, Vijay Janapa Reddi, and Kim Hazelwood. 2005. Pin: Building customized program analysis tools with dynamic instrumentation. \emph{Acm sigplan notices} 40, 6 (2005), 190--200.}

\bibitem[\citeproctext]{ref-millerfuzzing}
\CSLLeftMargin{{[}40{]} }%
\CSLRightInline{Barton P Miller, Lars Fredriksen, and Bryan So. 1990. An empirical study of the reliability of UNIX utilities. \emph{Communications of the ACM} 33, 12 (1990), 32--44.}

\bibitem[\citeproctext]{ref-artoftesting}
\CSLLeftMargin{{[}41{]} }%
\CSLRightInline{Glenford J Myers, Corey Sandler, and Tom Badgett. 2011. \emph{The art of software testing}. John Wiley \& Sons.}

\bibitem[\citeproctext]{ref-nunes2019vrased}
\CSLLeftMargin{{[}42{]} }%
\CSLRightInline{Ivan De Oliveira Nunes, Karim Eldefrawy, Norrathep Rattanavipanon, Michael Steiner, and Gene Tsudik. 2019. \(\{\)VRASED\(\}\): A verified \(\{\)hardware/software\(\}\)\(\{\)co-design\(\}\) for remote attestation. In \emph{28th USENIX security symposium (USENIX security 19)}, 2019. 1429--1446.}

\bibitem[\citeproctext]{ref-nunes2021tiny}
\CSLLeftMargin{{[}43{]} }%
\CSLRightInline{Ivan De Oliveira Nunes, Sashidhar Jakkamsetti, and Gene Tsudik. 2021. Tiny-CFA: Minimalistic control-flow attestation using verified proofs of execution. In \emph{2021 design, automation \& test in europe conference \& exhibition (DATE)}, 2021. IEEE, 641--646.}

\bibitem[\citeproctext]{ref-quinlan2009source}
\CSLLeftMargin{{[}44{]} }%
\CSLRightInline{Daniel Quinlan and Thomas Panas. 2009. Source code and binary analysis of software defects. In \emph{Proceedings of the 5th annual workshop on cyber security and information intelligence research: Cyber security and information intelligence challenges and strategies}, 2009. 1--4.}

\bibitem[\citeproctext]{ref-ravichandran2022pacman}
\CSLLeftMargin{{[}45{]} }%
\CSLRightInline{Joseph Ravichandran, Weon Taek Na, Jay Lang, and Mengjia Yan. 2022. PACMAN: Attacking ARM pointer authentication with speculative execution. In \emph{Proceedings of the 49th annual international symposium on computer architecture}, 2022. 685--698.}

\bibitem[\citeproctext]{ref-sadeghi2004property}
\CSLLeftMargin{{[}46{]} }%
\CSLRightInline{Ahmad-Reza Sadeghi and Christian Stble. 2004. Property-based attestation for computing platforms: Caring about properties, not mechanisms. In \emph{Proceedings of the 2004 workshop on new security paradigms}, 2004. 67--77.}

\bibitem[\citeproctext]{ref-bruceessay}
\CSLLeftMargin{{[}47{]} }%
\CSLRightInline{Bruce Schneier. 2000. The process of security. Retrieved from \url{https://www.schneier.com/essays/archives/2000/04/the_process_of_secur.html}}

\bibitem[\citeproctext]{ref-seshadri2005pioneer}
\CSLLeftMargin{{[}48{]} }%
\CSLRightInline{Arvind Seshadri, Mark Luk, Elaine Shi, Adrian Perrig, Leendert Van Doorn, and Pradeep Khosla. 2005. Pioneer: Verifying code integrity and enforcing untampered code execution on legacy systems. In \emph{Proceedings of the twentieth ACM symposium on operating systems principles}, 2005. 1--16.}

\bibitem[\citeproctext]{ref-seshadri2004swatt}
\CSLLeftMargin{{[}49{]} }%
\CSLRightInline{Arvind Seshadri, Adrian Perrig, Leendert Van Doorn, and Pradeep Khosla. 2004. SWATT: Software-based attestation for embedded devices. In \emph{IEEE symposium on security and privacy, 2004. Proceedings. 2004}, 2004. IEEE, 272--282.}

\bibitem[\citeproctext]{ref-so-xnu-abi}
\CSLLeftMargin{{[}50{]} }%
\CSLRightInline{Siguza. 2023. XNU systemcall ABI summary - StackOverflow. Retrieved from \url{https://stackoverflow.com/a/56993314}}

\bibitem[\citeproctext]{ref-sipearl}
\CSLLeftMargin{{[}51{]} }%
\CSLRightInline{Sipearl. 2023. Control flow integrity on Arm64 systems. Retrieved from \url{https://sipearl.com/sipearl-white-paper-anti-malware-active-protection-on-arm64-systems}}

\bibitem[\citeproctext]{ref-sun2020oat}
\CSLLeftMargin{{[}52{]} }%
\CSLRightInline{Zhichuang Sun, Bo Feng, Long Lu, and Somesh Jha. 2020. OAT: Attesting operation integrity of embedded devices. In \emph{2020 IEEE symposium on security and privacy (SP)}, 2020. IEEE, 1433--1449.}

\bibitem[\citeproctext]{ref-toffalini2019scarr}
\CSLLeftMargin{{[}53{]} }%
\CSLRightInline{Flavio Toffalini, Eleonora Losiouk, Andrea Biondo, Jianying Zhou, and Mauro Conti. 2019. \(\{\)ScaRR\(\}\): Scalable runtime remote attestation for complex systems. In \emph{22nd international symposium on research in attacks, intrusions and defenses (RAID 2019)}, 2019. 121--134.}

\bibitem[\citeproctext]{ref-walfish2015verifying}
\CSLLeftMargin{{[}54{]} }%
\CSLRightInline{Michael Walfish and Andrew J Blumberg. 2015. Verifying computations without reexecuting them. \emph{Communications of the ACM} 58, 2 (2015), 74--84.}

\bibitem[\citeproctext]{ref-blast}
\CSLLeftMargin{{[}55{]} }%
\CSLRightInline{Nikita Yadav and Vinod Ganapathy. 2023. Whole-program control-flow path attestation. In \emph{Proceedings of the 2023 ACM SIGSAC conference on computer and communications security}, 2023. 2680--2694.}

\bibitem[\citeproctext]{ref-mte-kern-patch}
\CSLLeftMargin{{[}56{]} }%
\CSLRightInline{Yeoreum Yun. 2025. Kernel patch - support for FEAT\_MTE\_STORE\_ONLY feature. Retrieved from \url{https://lwn.net/ml/all/20250507154654.1937588-1-yeoreum.yun@arm.com/}}

\bibitem[\citeproctext]{ref-zhang2021recfa}
\CSLLeftMargin{{[}57{]} }%
\CSLRightInline{Yumei Zhang, Xinzhi Liu, Cong Sun, Dongrui Zeng, Gang Tan, Xiao Kan, and Siqi Ma. 2021. Recfa: Resilient control-flow attestation. In \emph{Proceedings of the 37th annual computer security applications conference}, 2021. 311--322.}

\end{CSLReferences}

%%%%% REFERENCES


\end{document}
